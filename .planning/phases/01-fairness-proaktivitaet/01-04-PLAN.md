---
phase: 01-fairness-proaktivitaet
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - supabase/migrations/20260201_quest_expiry_notification.sql
  - src/lib/cron/quest-expiry-scheduler.ts
  - src/instrumentation.ts
autonomous: true

must_haves:
  truths:
    - "Users receive notification 24 hours before quest expires"
    - "Notifications include quest title and remaining time"
    - "No duplicate expiry notifications sent"
    - "Only active quests with expiry dates trigger notifications"
  artifacts:
    - path: "supabase/migrations/20260201_quest_expiry_notification.sql"
      provides: "Column for tracking expiry notification status"
      contains: "expiry_notified_at"
    - path: "src/lib/cron/quest-expiry-scheduler.ts"
      provides: "Cron job for quest expiry notifications"
      exports: ["initQuestExpiryScheduler"]
    - path: "src/instrumentation.ts"
      provides: "Server initialization with quest expiry scheduler"
      contains: "initQuestExpiryScheduler"
  key_links:
    - from: "src/lib/cron/quest-expiry-scheduler.ts"
      to: "quests"
      via: "supabase query"
      pattern: "from.*quests.*expires_at"
    - from: "src/instrumentation.ts"
      to: "src/lib/cron/quest-expiry-scheduler.ts"
      via: "dynamic import"
      pattern: "import.*quest-expiry-scheduler"
---

<objective>
Implement Quest Expiration Notifications that warn users 24 hours before their quests expire.

Purpose: Prevent frustration from missed quests. Users get a reminder notification 24 hours before a quest's deadline, giving them time to complete it or consciously let it expire. This supports the "fair gamification" principle by not blindsiding users.

Output:
- Database column for tracking notification status
- Cron scheduler that runs hourly to check expiring quests
- Integration with existing notification infrastructure
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-fairness-proaktivitaet/01-RESEARCH.md

Key existing patterns:
- Cron infrastructure: `src/lib/cron/reminder-scheduler.ts`
- Server initialization: `src/instrumentation.ts`
- Quest table has `expires_at` TIMESTAMPTZ column
- Notification settings: `src/lib/data/notifications.ts`
- Web Push already configured with VAPID
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for quest expiry tracking</name>
  <files>supabase/migrations/20260201_quest_expiry_notification.sql</files>
  <action>
Create migration file:

```sql
-- Quest Expiry Notification Tracking
-- Adds column to track when expiry notification was sent

ALTER TABLE quests
  ADD COLUMN IF NOT EXISTS expiry_notified_at TIMESTAMPTZ;

-- Index for efficient querying of quests needing notification
CREATE INDEX IF NOT EXISTS idx_quests_expiring
  ON quests(user_id, expires_at)
  WHERE status = 'active' AND expires_at IS NOT NULL AND expiry_notified_at IS NULL;

COMMENT ON COLUMN quests.expiry_notified_at IS 'Timestamp when 24h expiry notification was sent';
```
  </action>
  <verify>
```bash
cat supabase/migrations/20260201_quest_expiry_notification.sql
```
  </verify>
  <done>Migration adds expiry_notified_at column to quests table with appropriate index</done>
</task>

<task type="auto">
  <name>Task 2: Create quest expiry notification scheduler</name>
  <files>src/lib/cron/quest-expiry-scheduler.ts</files>
  <action>
Create the scheduler following existing patterns:

```typescript
// ============================================
// Projekt L - Quest Expiry Notification Scheduler
// Notifies users 24 hours before quests expire
// ============================================

import cron from 'node-cron';
import { createClient } from '@supabase/supabase-js';
import webpush from 'web-push';

// Configure web-push lazily
let vapidConfigured = false;
function ensureVapidConfigured() {
  if (!vapidConfigured && process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY && process.env.VAPID_PRIVATE_KEY) {
    webpush.setVapidDetails(
      process.env.VAPID_SUBJECT || 'mailto:lukas@projekt-l.de',
      process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY,
      process.env.VAPID_PRIVATE_KEY
    );
    vapidConfigured = true;
  }
}

// Supabase client with service role
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Quest type icons
const QUEST_TYPE_ICONS: Record<string, string> = {
  daily: 'üìÖ',
  weekly: 'üìÜ',
  story: 'üìñ',
};

interface ExpiringQuest {
  id: string;
  user_id: string;
  title: string;
  type: string;
  expires_at: string;
  progress: number;
}

/**
 * Calculate hours remaining until expiry
 */
function hoursUntilExpiry(expiresAt: string): number {
  const expiry = new Date(expiresAt);
  const now = new Date();
  return Math.floor((expiry.getTime() - now.getTime()) / (1000 * 60 * 60));
}

/**
 * Format remaining time for notification
 */
function formatRemainingTime(hours: number): string {
  if (hours <= 1) return 'weniger als 1 Stunde';
  if (hours < 24) return `${hours} Stunden`;
  const days = Math.floor(hours / 24);
  return `${days} Tag${days > 1 ? 'e' : ''}`;
}

/**
 * Check if user is in quiet hours
 */
async function isUserInQuietHours(userId: string): Promise<boolean> {
  const { data: settings } = await supabase
    .from('notification_settings')
    .select('quiet_hours_enabled, quiet_hours_start, quiet_hours_end, user_profiles!inner(timezone)')
    .eq('user_id', userId)
    .single();

  if (!settings?.quiet_hours_enabled) return false;

  const timezone = (settings.user_profiles as any)?.timezone || 'Europe/Berlin';
  const now = new Date();
  const currentTime = now.toLocaleTimeString('de-DE', {
    timeZone: timezone,
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  });

  const start = settings.quiet_hours_start || '22:00';
  const end = settings.quiet_hours_end || '08:00';

  if (start > end) {
    return currentTime >= start || currentTime < end;
  }

  return currentTime >= start && currentTime < end;
}

/**
 * Send push notification for expiring quest
 */
async function sendExpiryNotification(
  quest: ExpiringQuest,
  subscription: any
): Promise<boolean> {
  const hoursLeft = hoursUntilExpiry(quest.expires_at);
  const icon = QUEST_TYPE_ICONS[quest.type] || '‚öîÔ∏è';

  const payload = JSON.stringify({
    title: `${icon} Quest laeuft bald ab!`,
    body: `"${quest.title}" laeuft in ${formatRemainingTime(hoursLeft)} ab. Noch ${quest.progress}% erledigt.`,
    url: `/quests/${quest.id}`,
    tag: `quest-expiry-${quest.id}`,
    renotify: false,
    data: {
      type: 'quest_expiry',
      questId: quest.id,
    },
  });

  try {
    ensureVapidConfigured();
    await webpush.sendNotification(subscription, payload);

    // Mark as notified
    await supabase
      .from('quests')
      .update({ expiry_notified_at: new Date().toISOString() })
      .eq('id', quest.id);

    console.log(`[Quest Expiry] Sent notification for quest: ${quest.title}`);
    return true;
  } catch (error: any) {
    console.error('[Quest Expiry] Push error:', error);

    // Handle expired subscription
    if (error.statusCode === 410 || error.statusCode === 404) {
      await supabase
        .from('notification_settings')
        .update({ push_enabled: false, push_subscription: null })
        .eq('user_id', quest.user_id);
    }
    return false;
  }
}

/**
 * Main function to check and notify about expiring quests
 */
async function checkExpiringQuests(): Promise<void> {
  try {
    console.log('[Quest Expiry] Checking for expiring quests...');

    // Find quests expiring within the next 24 hours that haven't been notified
    const now = new Date();
    const twentyFourHoursFromNow = new Date(now.getTime() + 24 * 60 * 60 * 1000);

    const { data: quests, error } = await supabase
      .from('quests')
      .select(`
        id,
        user_id,
        title,
        type,
        expires_at,
        progress
      `)
      .eq('status', 'active')
      .not('expires_at', 'is', null)
      .is('expiry_notified_at', null)
      .gte('expires_at', now.toISOString())
      .lte('expires_at', twentyFourHoursFromNow.toISOString());

    if (error) {
      console.error('[Quest Expiry] Error fetching quests:', error);
      return;
    }

    if (!quests || quests.length === 0) {
      console.log('[Quest Expiry] No expiring quests found');
      return;
    }

    console.log(`[Quest Expiry] Found ${quests.length} expiring quest(s)`);

    // Group quests by user to batch notifications
    const questsByUser = quests.reduce((acc, quest) => {
      if (!acc[quest.user_id]) acc[quest.user_id] = [];
      acc[quest.user_id].push(quest);
      return acc;
    }, {} as Record<string, ExpiringQuest[]>);

    let notificationsSent = 0;

    for (const [userId, userQuests] of Object.entries(questsByUser)) {
      try {
        // Check quiet hours
        if (await isUserInQuietHours(userId)) {
          console.log(`[Quest Expiry] Skipping user ${userId} (quiet hours)`);
          continue;
        }

        // Get user's push subscription
        const { data: settings } = await supabase
          .from('notification_settings')
          .select('push_enabled, push_subscription')
          .eq('user_id', userId)
          .single();

        if (!settings?.push_enabled || !settings.push_subscription) {
          continue;
        }

        // Send notification for most urgent quest only (avoid spam)
        const mostUrgent = userQuests.sort(
          (a, b) => new Date(a.expires_at).getTime() - new Date(b.expires_at).getTime()
        )[0];

        const sent = await sendExpiryNotification(mostUrgent, settings.push_subscription);

        if (sent) {
          notificationsSent++;

          // Mark other quests as notified too (batch notification)
          if (userQuests.length > 1) {
            const otherQuestIds = userQuests
              .filter(q => q.id !== mostUrgent.id)
              .map(q => q.id);

            await supabase
              .from('quests')
              .update({ expiry_notified_at: new Date().toISOString() })
              .in('id', otherQuestIds);
          }
        }
      } catch (err) {
        console.error(`[Quest Expiry] Error processing user ${userId}:`, err);
      }
    }

    console.log(`[Quest Expiry] Check complete. Sent ${notificationsSent} notification(s).`);
  } catch (error) {
    console.error('[Quest Expiry] Fatal error:', error);
  }
}

/**
 * Initialize the quest expiry notification scheduler
 */
export function initQuestExpiryScheduler(): void {
  // Run every hour at minute 0
  cron.schedule('0 * * * *', () => {
    checkExpiringQuests();
  });

  console.log('[Quest Expiry] ‚úÖ Initialized - Running hourly');
}
```
  </action>
  <verify>
```bash
# Check file exists
cat src/lib/cron/quest-expiry-scheduler.ts | head -50

# Check exports
grep "export function" src/lib/cron/quest-expiry-scheduler.ts

# Build check
npm run build 2>&1 | head -30
```
  </verify>
  <done>Quest expiry scheduler runs hourly and sends notifications 24h before expiry</done>
</task>

<task type="auto">
  <name>Task 3: Update instrumentation.ts to include quest expiry scheduler</name>
  <files>src/instrumentation.ts</files>
  <action>
Update instrumentation.ts to include all schedulers. The file should now look like:

```typescript
// ============================================
// Projekt L - Server Instrumentation
// Runs ONCE when Next.js server starts
// ============================================

export async function register() {
  // Only run on Node.js server, not in Edge runtime
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    const { initReminderScheduler } = await import('./lib/cron/reminder-scheduler');
    const { initProactiveScheduler } = await import('./lib/cron/proactive-scheduler');
    const { initQuestExpiryScheduler } = await import('./lib/cron/quest-expiry-scheduler');

    console.log('[Instrumentation] Server starting...');
    console.log('[Instrumentation] Initializing schedulers...');

    initReminderScheduler();
    initProactiveScheduler();
    initQuestExpiryScheduler();

    console.log('[Instrumentation] All schedulers initialized ‚úÖ');
  }
}
```

Note: If Plan 02 has already been executed, the proactive scheduler import will already exist. Simply add the quest expiry scheduler import and initialization call.
  </action>
  <verify>
```bash
# Check all schedulers are imported
grep -n "initQuestExpiryScheduler\|initProactiveScheduler\|initReminderScheduler" src/instrumentation.ts

# Build check
npm run build 2>&1 | head -30
```
  </verify>
  <done>instrumentation.ts imports and initializes quest expiry scheduler</done>
</task>

</tasks>

<verification>
1. Migration adds `expiry_notified_at` column to quests table
2. Quest expiry scheduler exports `initQuestExpiryScheduler` function
3. Scheduler queries quests expiring within 24 hours
4. Scheduler respects quiet hours via `isUserInQuietHours` check
5. Scheduler marks quests as notified after sending
6. instrumentation.ts initializes all three schedulers
7. TypeScript compiles without errors: `npm run build`
</verification>

<success_criteria>
- [ ] Database migration adds expiry_notified_at column to quests
- [ ] Quest expiry scheduler runs hourly via cron
- [ ] Scheduler finds active quests expiring within 24 hours
- [ ] Scheduler skips quests already notified (expiry_notified_at not null)
- [ ] Scheduler respects quiet hours settings
- [ ] Notifications include quest title and time remaining
- [ ] Scheduler marks quests as notified after sending
- [ ] instrumentation.ts initializes quest expiry scheduler
- [ ] All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-fairness-proaktivitaet/01-04-SUMMARY.md`
</output>
