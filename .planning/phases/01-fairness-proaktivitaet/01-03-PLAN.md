---
phase: 01-fairness-proaktivitaet
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260201_habit_health_mappings.sql
  - src/lib/types/health-import.ts
  - src/lib/data/health-import.ts
  - src/app/api/integrations/health-import/webhook/route.ts
  - src/app/api/habits/health-mapping/route.ts
  - src/components/health-import/HabitHealthMapping.tsx
autonomous: true

must_haves:
  truths:
    - "Users can configure which habits auto-complete from health imports"
    - "Workout imports auto-complete matching habits"
    - "Habits are not completed twice on same day"
    - "Auto-completion grants XP like normal completion"
  artifacts:
    - path: "supabase/migrations/20260201_habit_health_mappings.sql"
      provides: "Database table for habit-workout mappings"
      contains: "CREATE TABLE habit_health_mappings"
    - path: "src/lib/data/health-import.ts"
      provides: "Extended import logic with habit matching"
      contains: "matchAndCompleteHabits"
    - path: "src/app/api/habits/health-mapping/route.ts"
      provides: "API for managing mappings"
      exports: ["GET", "POST", "DELETE"]
    - path: "src/components/health-import/HabitHealthMapping.tsx"
      provides: "UI for configuring mappings"
      min_lines: 60
  key_links:
    - from: "src/lib/data/health-import.ts"
      to: "habit_health_mappings"
      via: "supabase query"
      pattern: "from.*habit_health_mappings"
    - from: "src/app/api/integrations/health-import/webhook/route.ts"
      to: "matchAndCompleteHabits"
      via: "function call"
      pattern: "matchAndCompleteHabits"
---

<objective>
Implement Health Import to Habit Auto-Complete linking that automatically completes habits when matching workouts are imported from Apple Health.

Purpose: Reduce manual tracking by connecting health data to habits. When a user imports a "running" workout from Apple Health and has a "Laufen gehen" habit, the habit is automatically marked as complete. This creates a seamless experience between external fitness tracking and the gamification system.

Output:
- Database table for user-defined workout-to-habit mappings
- Extended webhook to check and complete matching habits
- UI component for users to configure their mappings
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-fairness-proaktivitaet/01-RESEARCH.md

Key existing patterns:
- Health import webhook: `src/app/api/integrations/health-import/webhook/route.ts`
- Health import data layer: `src/lib/data/health-import.ts`
- Habit completion: `src/lib/data/habits.ts` (logHabit function)
- Health import types: HealthWorkout, HealthImportData
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for habit_health_mappings</name>
  <files>supabase/migrations/20260201_habit_health_mappings.sql</files>
  <action>
Create migration file:

```sql
-- Habit Health Mappings
-- Links health import workout types to habits for auto-completion

CREATE TABLE IF NOT EXISTS habit_health_mappings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  habit_id UUID NOT NULL REFERENCES habits(id) ON DELETE CASCADE,

  -- Workout matching criteria
  health_workout_type TEXT NOT NULL,
  min_duration_minutes INTEGER DEFAULT 0,

  -- Settings
  enabled BOOLEAN DEFAULT TRUE,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- One mapping per habit-workout combination
  UNIQUE(habit_id, health_workout_type)
);

-- Indexes for fast lookup
CREATE INDEX idx_habit_health_user ON habit_health_mappings(user_id);
CREATE INDEX idx_habit_health_workout ON habit_health_mappings(health_workout_type);
CREATE INDEX idx_habit_health_enabled ON habit_health_mappings(user_id, enabled)
  WHERE enabled = TRUE;

-- RLS policies
ALTER TABLE habit_health_mappings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own mappings" ON habit_health_mappings
  FOR ALL USING (auth.uid() = user_id);

-- Auto-update updated_at
CREATE TRIGGER update_habit_health_mappings_updated_at
  BEFORE UPDATE ON habit_health_mappings
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

COMMENT ON TABLE habit_health_mappings IS 'User-defined links between health workout types and habits for auto-completion';

-- Common workout types reference (as comment for documentation)
-- running, walking, hiking, cycling, swimming
-- strength_training, functional_strength, traditional_strength
-- yoga, pilates, flexibility
-- elliptical, stair_climbing, rowing
-- dance, martial_arts, boxing
```
  </action>
  <verify>
```bash
cat supabase/migrations/20260201_habit_health_mappings.sql
```
  </verify>
  <done>Migration creates habit_health_mappings with unique constraint on (habit_id, health_workout_type)</done>
</task>

<task type="auto">
  <name>Task 2: Extend health import with habit auto-completion</name>
  <files>
    src/lib/types/health-import.ts
    src/lib/data/health-import.ts
  </files>
  <action>
First, create/update types file `src/lib/types/health-import.ts`:

```typescript
// ============================================
// Health Import Types
// ============================================

export interface HealthWorkout {
  workoutType: string;
  startDate: string;
  endDate: string;
  duration: number; // minutes
  caloriesBurned?: number;
  distance?: number; // km
  heartRateAvg?: number;
  externalId: string;
}

export interface HealthBodyMetric {
  type: 'weight' | 'body_fat' | 'height';
  value: number;
  unit: string;
  date: string;
  externalId: string;
}

export interface HealthSteps {
  date: string;
  steps: number;
  distance?: number;
  externalId: string;
}

export interface HealthSleep {
  startDate: string;
  endDate: string;
  duration: number;
  quality?: 'deep' | 'light' | 'rem' | 'awake';
  externalId: string;
}

export interface HealthImportData {
  workouts?: HealthWorkout[];
  bodyMetrics?: HealthBodyMetric[];
  steps?: HealthSteps[];
  sleep?: HealthSleep[];
}

export interface HabitHealthMapping {
  id: string;
  user_id: string;
  habit_id: string;
  health_workout_type: string;
  min_duration_minutes: number;
  enabled: boolean;
  created_at: string;
  updated_at: string;
}

export interface HabitAutoCompleteResult {
  habitId: string;
  habitName: string;
  xpGained: number;
  workoutType: string;
}

export interface ImportResult {
  success: boolean;
  imported: {
    workouts: number;
    bodyMetrics: number;
    steps: number;
    sleep: number;
  };
  skipped: {
    workouts: number;
    bodyMetrics: number;
    steps: number;
    sleep: number;
  };
  totalXP: number;
  errors: string[];
  habitsAutoCompleted: HabitAutoCompleteResult[];
}

// Workout type normalization map
export const WORKOUT_TYPE_ALIASES: Record<string, string> = {
  // Running
  running: 'running',
  jogging: 'running',
  run: 'running',
  // Walking
  walking: 'walking',
  walk: 'walking',
  hiking: 'hiking',
  // Cycling
  cycling: 'cycling',
  biking: 'cycling',
  indoor_cycling: 'cycling',
  // Strength
  strength_training: 'strength_training',
  traditional_strength: 'strength_training',
  functional_strength: 'strength_training',
  weight_training: 'strength_training',
  // Yoga/Flexibility
  yoga: 'yoga',
  pilates: 'pilates',
  flexibility: 'flexibility',
  stretching: 'flexibility',
  // Swimming
  swimming: 'swimming',
  pool_swim: 'swimming',
  open_water_swim: 'swimming',
};
```

Now update `src/lib/data/health-import.ts` to add the habit matching logic. Add these functions after the existing code:

```typescript
// ============================================
// HABIT AUTO-COMPLETION FROM HEALTH IMPORTS
// ============================================

import type {
  HabitHealthMapping,
  HabitAutoCompleteResult,
  HealthWorkout,
  WORKOUT_TYPE_ALIASES
} from '@/lib/types/health-import';

/**
 * Normalize workout type to standard name
 */
export function normalizeWorkoutType(workoutType: string): string {
  const normalized = workoutType.toLowerCase().replace(/[- ]/g, '_');
  return WORKOUT_TYPE_ALIASES[normalized] || normalized;
}

/**
 * Get active health mappings for a user
 */
export async function getHealthMappings(userId: string): Promise<HabitHealthMapping[]> {
  const supabase = createBrowserClient();

  const { data, error } = await supabase
    .from('habit_health_mappings')
    .select('*')
    .eq('user_id', userId)
    .eq('enabled', true);

  if (error) {
    console.error('Error fetching health mappings:', error);
    return [];
  }

  return data || [];
}

/**
 * Match and auto-complete habits based on imported workout
 */
export async function matchAndCompleteHabits(
  userId: string,
  workout: HealthWorkout
): Promise<HabitAutoCompleteResult[]> {
  const supabase = createBrowserClient();
  const results: HabitAutoCompleteResult[] = [];

  const normalizedType = normalizeWorkoutType(workout.workoutType);

  // Find matching mappings
  const { data: mappings, error: mappingError } = await supabase
    .from('habit_health_mappings')
    .select(`
      *,
      habits!inner (
        id,
        name,
        xp_per_completion,
        is_active
      )
    `)
    .eq('user_id', userId)
    .eq('enabled', true)
    .eq('health_workout_type', normalizedType)
    .lte('min_duration_minutes', workout.duration);

  if (mappingError || !mappings || mappings.length === 0) {
    return results;
  }

  const today = new Date().toISOString().split('T')[0];

  for (const mapping of mappings) {
    const habit = mapping.habits as any;

    if (!habit || !habit.is_active) continue;

    // Check if habit already completed today
    const { data: existingLog } = await supabase
      .from('habit_logs')
      .select('id')
      .eq('habit_id', habit.id)
      .eq('user_id', userId)
      .gte('logged_at', today)
      .eq('completed', true)
      .limit(1)
      .single();

    if (existingLog) {
      console.log(`[Health Import] Habit ${habit.name} already completed today, skipping`);
      continue;
    }

    // Auto-complete the habit
    try {
      const { data: logData, error: logError } = await supabase
        .from('habit_logs')
        .insert({
          habit_id: habit.id,
          user_id: userId,
          logged_at: new Date().toISOString(),
          completed: true,
          notes: `Auto-completed via Health Import (${workout.workoutType}, ${workout.duration} min)`,
          duration_minutes: workout.duration,
          source: 'health_import',
        })
        .select()
        .single();

      if (logError) throw logError;

      // Update habit streak
      await supabase
        .from('habits')
        .update({
          current_streak: supabase.raw('current_streak + 1'),
          last_completed_at: new Date().toISOString(),
        })
        .eq('id', habit.id);

      const xpGained = habit.xp_per_completion || 10;

      results.push({
        habitId: habit.id,
        habitName: habit.name,
        xpGained,
        workoutType: workout.workoutType,
      });

      console.log(`[Health Import] Auto-completed habit: ${habit.name} (+${xpGained} XP)`);
    } catch (err) {
      console.error(`[Health Import] Failed to auto-complete habit ${habit.name}:`, err);
    }
  }

  return results;
}

/**
 * Create a habit-health mapping
 */
export async function createHealthMapping(
  userId: string,
  habitId: string,
  workoutType: string,
  minDuration: number = 0
): Promise<HabitHealthMapping> {
  const supabase = createBrowserClient();

  const normalizedType = normalizeWorkoutType(workoutType);

  const { data, error } = await supabase
    .from('habit_health_mappings')
    .insert({
      user_id: userId,
      habit_id: habitId,
      health_workout_type: normalizedType,
      min_duration_minutes: minDuration,
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating health mapping:', error);
    throw error;
  }

  return data;
}

/**
 * Delete a habit-health mapping
 */
export async function deleteHealthMapping(mappingId: string): Promise<void> {
  const supabase = createBrowserClient();

  const { error } = await supabase
    .from('habit_health_mappings')
    .delete()
    .eq('id', mappingId);

  if (error) {
    console.error('Error deleting health mapping:', error);
    throw error;
  }
}
```

Also update the existing `importWorkouts` function in health-import.ts to call `matchAndCompleteHabits` after importing each workout, and aggregate the results into the ImportResult.
  </action>
  <verify>
```bash
# Check types file
head -50 src/lib/types/health-import.ts

# Check new functions in data file
grep -n "matchAndCompleteHabits\|normalizeWorkoutType" src/lib/data/health-import.ts

# Build check
npm run build 2>&1 | head -30
```
  </verify>
  <done>Health import data layer includes matchAndCompleteHabits function with duplicate prevention</done>
</task>

<task type="auto">
  <name>Task 3: Create API endpoint for managing health mappings</name>
  <files>src/app/api/habits/health-mapping/route.ts</files>
  <action>
Create `src/app/api/habits/health-mapping/route.ts`:

```typescript
// ============================================
// Habit Health Mapping API
// Manage workout-to-habit auto-complete mappings
// ============================================

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

/**
 * GET /api/habits/health-mapping
 * List all health mappings for current user
 */
export async function GET() {
  try {
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { data, error } = await supabase
      .from('habit_health_mappings')
      .select(`
        *,
        habits (
          id,
          name,
          icon
        )
      `)
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('[Health Mapping API] Error:', error);
      return NextResponse.json({ error: 'Failed to fetch mappings' }, { status: 500 });
    }

    return NextResponse.json({ mappings: data || [] });
  } catch (error) {
    console.error('[Health Mapping API] Error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

/**
 * POST /api/habits/health-mapping
 * Create a new health mapping
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { habitId, workoutType, minDurationMinutes = 0 } = body;

    if (!habitId || !workoutType) {
      return NextResponse.json(
        { error: 'habitId and workoutType are required' },
        { status: 400 }
      );
    }

    // Verify habit belongs to user
    const { data: habit, error: habitError } = await supabase
      .from('habits')
      .select('id, name')
      .eq('id', habitId)
      .eq('user_id', user.id)
      .single();

    if (habitError || !habit) {
      return NextResponse.json({ error: 'Habit not found' }, { status: 404 });
    }

    // Normalize workout type
    const normalizedType = workoutType.toLowerCase().replace(/[- ]/g, '_');

    // Create mapping
    const { data, error } = await supabase
      .from('habit_health_mappings')
      .insert({
        user_id: user.id,
        habit_id: habitId,
        health_workout_type: normalizedType,
        min_duration_minutes: minDurationMinutes,
      })
      .select()
      .single();

    if (error) {
      if (error.code === '23505') {
        return NextResponse.json(
          { error: 'Mapping already exists for this habit and workout type' },
          { status: 409 }
        );
      }
      console.error('[Health Mapping API] Error:', error);
      return NextResponse.json({ error: 'Failed to create mapping' }, { status: 500 });
    }

    return NextResponse.json({ mapping: data }, { status: 201 });
  } catch (error) {
    console.error('[Health Mapping API] Error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

/**
 * DELETE /api/habits/health-mapping
 * Delete a health mapping
 */
export async function DELETE(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const mappingId = searchParams.get('id');

    if (!mappingId) {
      return NextResponse.json({ error: 'id is required' }, { status: 400 });
    }

    // Delete mapping (RLS ensures user can only delete own)
    const { error } = await supabase
      .from('habit_health_mappings')
      .delete()
      .eq('id', mappingId)
      .eq('user_id', user.id);

    if (error) {
      console.error('[Health Mapping API] Delete error:', error);
      return NextResponse.json({ error: 'Failed to delete mapping' }, { status: 500 });
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('[Health Mapping API] Error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```
  </action>
  <verify>
```bash
# Check file exists
ls -la src/app/api/habits/health-mapping/route.ts

# Build check
npm run build 2>&1 | head -30
```
  </verify>
  <done>API endpoints for GET, POST, DELETE on health mappings follow existing patterns</done>
</task>

<task type="auto">
  <name>Task 4: Create UI component for health mapping configuration</name>
  <files>src/components/health-import/HabitHealthMapping.tsx</files>
  <action>
Create `src/components/health-import/HabitHealthMapping.tsx`:

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Activity, Plus, Trash2, Loader2, Check } from 'lucide-react';
import type { HabitHealthMapping } from '@/lib/types/health-import';

// Common workout types for selection
const WORKOUT_TYPES = [
  { value: 'running', label: 'Laufen / Joggen' },
  { value: 'walking', label: 'Spazieren' },
  { value: 'hiking', label: 'Wandern' },
  { value: 'cycling', label: 'Radfahren' },
  { value: 'swimming', label: 'Schwimmen' },
  { value: 'strength_training', label: 'Krafttraining' },
  { value: 'yoga', label: 'Yoga' },
  { value: 'pilates', label: 'Pilates' },
  { value: 'flexibility', label: 'Dehnen / Mobilitaet' },
];

interface Habit {
  id: string;
  name: string;
  icon: string;
}

interface MappingWithHabit extends HabitHealthMapping {
  habits: Habit;
}

interface HabitHealthMappingProps {
  className?: string;
}

export function HabitHealthMappingConfig({ className = '' }: HabitHealthMappingProps) {
  const [mappings, setMappings] = useState<MappingWithHabit[]>([]);
  const [habits, setHabits] = useState<Habit[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // New mapping form state
  const [showAddForm, setShowAddForm] = useState(false);
  const [selectedHabit, setSelectedHabit] = useState('');
  const [selectedWorkout, setSelectedWorkout] = useState('');
  const [minDuration, setMinDuration] = useState(0);

  useEffect(() => {
    fetchData();
  }, []);

  async function fetchData() {
    try {
      setLoading(true);

      // Fetch mappings and habits in parallel
      const [mappingsRes, habitsRes] = await Promise.all([
        fetch('/api/habits/health-mapping'),
        fetch('/api/habits/list'),
      ]);

      if (!mappingsRes.ok || !habitsRes.ok) {
        throw new Error('Failed to fetch data');
      }

      const mappingsData = await mappingsRes.json();
      const habitsData = await habitsRes.json();

      setMappings(mappingsData.mappings || []);
      setHabits(habitsData.data || []);
    } catch (err) {
      setError('Konnte Daten nicht laden');
      console.error(err);
    } finally {
      setLoading(false);
    }
  }

  async function handleAddMapping() {
    if (!selectedHabit || !selectedWorkout) return;

    try {
      setSaving(true);
      setError(null);

      const response = await fetch('/api/habits/health-mapping', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          habitId: selectedHabit,
          workoutType: selectedWorkout,
          minDurationMinutes: minDuration,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to create mapping');
      }

      // Refresh data
      await fetchData();

      // Reset form
      setShowAddForm(false);
      setSelectedHabit('');
      setSelectedWorkout('');
      setMinDuration(0);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Fehler beim Erstellen');
    } finally {
      setSaving(false);
    }
  }

  async function handleDeleteMapping(mappingId: string) {
    try {
      const response = await fetch(`/api/habits/health-mapping?id=${mappingId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to delete mapping');
      }

      setMappings(mappings.filter(m => m.id !== mappingId));
    } catch (err) {
      setError('Konnte Mapping nicht loeschen');
    }
  }

  if (loading) {
    return (
      <div className={`bg-white dark:bg-gray-800 rounded-xl p-6 ${className}`}>
        <div className="flex items-center justify-center py-8">
          <Loader2 className="w-6 h-6 animate-spin text-gray-400" />
        </div>
      </div>
    );
  }

  return (
    <div className={`bg-white dark:bg-gray-800 rounded-xl p-6 ${className}`}>
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <div className="p-2 bg-green-100 dark:bg-green-900/30 rounded-lg">
            <Activity className="w-5 h-5 text-green-600" />
          </div>
          <div>
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
              Health Import Verknuepfungen
            </h2>
            <p className="text-sm text-gray-500">
              Verknuepfe Workouts mit Habits fuer Auto-Vervollstaendigung
            </p>
          </div>
        </div>

        <button
          onClick={() => setShowAddForm(true)}
          className="flex items-center gap-2 px-3 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
        >
          <Plus className="w-4 h-4" />
          Hinzufuegen
        </button>
      </div>

      {error && (
        <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 rounded-lg">
          <p className="text-sm text-red-600 dark:text-red-400">{error}</p>
        </div>
      )}

      {/* Add Form */}
      {showAddForm && (
        <div className="mb-6 p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
          <h3 className="font-medium mb-4">Neue Verknuepfung</h3>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <div>
              <label className="block text-sm font-medium mb-1">Habit</label>
              <select
                value={selectedHabit}
                onChange={(e) => setSelectedHabit(e.target.value)}
                className="w-full px-3 py-2 border rounded-lg dark:bg-gray-800 dark:border-gray-600"
              >
                <option value="">Waehle Habit...</option>
                {habits.map((habit) => (
                  <option key={habit.id} value={habit.id}>
                    {habit.icon} {habit.name}
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium mb-1">Workout-Typ</label>
              <select
                value={selectedWorkout}
                onChange={(e) => setSelectedWorkout(e.target.value)}
                className="w-full px-3 py-2 border rounded-lg dark:bg-gray-800 dark:border-gray-600"
              >
                <option value="">Waehle Workout...</option>
                {WORKOUT_TYPES.map((type) => (
                  <option key={type.value} value={type.value}>
                    {type.label}
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium mb-1">Min. Dauer (Min)</label>
              <input
                type="number"
                value={minDuration}
                onChange={(e) => setMinDuration(parseInt(e.target.value) || 0)}
                min={0}
                className="w-full px-3 py-2 border rounded-lg dark:bg-gray-800 dark:border-gray-600"
              />
            </div>
          </div>

          <div className="flex gap-2">
            <button
              onClick={handleAddMapping}
              disabled={saving || !selectedHabit || !selectedWorkout}
              className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50"
            >
              {saving ? <Loader2 className="w-4 h-4 animate-spin" /> : <Check className="w-4 h-4" />}
              Speichern
            </button>
            <button
              onClick={() => setShowAddForm(false)}
              className="px-4 py-2 border rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600"
            >
              Abbrechen
            </button>
          </div>
        </div>
      )}

      {/* Mappings List */}
      {mappings.length === 0 ? (
        <div className="text-center py-8 text-gray-500">
          <Activity className="w-12 h-12 mx-auto mb-2 opacity-50" />
          <p>Keine Verknuepfungen konfiguriert</p>
          <p className="text-sm">Fuege eine hinzu, um Habits automatisch zu vervollstaendigen</p>
        </div>
      ) : (
        <div className="space-y-3">
          {mappings.map((mapping) => (
            <div
              key={mapping.id}
              className="flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700/50 rounded-lg"
            >
              <div className="flex items-center gap-3">
                <span className="text-xl">{mapping.habits?.icon || 'âœ…'}</span>
                <div>
                  <p className="font-medium">{mapping.habits?.name || 'Unbekannt'}</p>
                  <p className="text-sm text-gray-500">
                    {WORKOUT_TYPES.find(t => t.value === mapping.health_workout_type)?.label || mapping.health_workout_type}
                    {mapping.min_duration_minutes > 0 && ` (min. ${mapping.min_duration_minutes} Min)`}
                  </p>
                </div>
              </div>

              <button
                onClick={() => handleDeleteMapping(mapping.id)}
                className="p-2 text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg"
              >
                <Trash2 className="w-4 h-4" />
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

Update the index file if it exists, or add export to existing health-import components index.
  </action>
  <verify>
```bash
# Check file exists
ls -la src/components/health-import/HabitHealthMapping.tsx

# Line count
wc -l src/components/health-import/HabitHealthMapping.tsx

# Build check
npm run build 2>&1 | head -30
```
  </verify>
  <done>HabitHealthMappingConfig component allows users to configure workout-to-habit mappings</done>
</task>

<task type="auto">
  <name>Task 5: Wire webhook to call matchAndCompleteHabits</name>
  <files>src/app/api/integrations/health-import/webhook/route.ts</files>
  <action>
Update the existing health import webhook to call matchAndCompleteHabits after processing workouts.

1. Add import at the top:
```typescript
import { matchAndCompleteHabits } from '@/lib/data/health-import';
```

2. After the workout import loop (where workouts are processed and saved), add the habit matching logic:

```typescript
// After processing each workout, check for habit auto-completion
const habitResults: HabitAutoCompleteResult[] = [];

if (importData.workouts && importData.workouts.length > 0) {
  for (const workout of importData.workouts) {
    try {
      const autoCompleted = await matchAndCompleteHabits(userId, workout);
      habitResults.push(...autoCompleted);
    } catch (err) {
      console.error('[Health Webhook] Error matching habits:', err);
    }
  }
}
```

3. Include the habit results in the response:
```typescript
return NextResponse.json({
  success: true,
  imported: { /* existing counts */ },
  skipped: { /* existing counts */ },
  totalXP: /* existing XP */ + habitResults.reduce((sum, h) => sum + h.xpGained, 0),
  habitsAutoCompleted: habitResults,
});
```

This ensures that when health data is imported via the webhook, any matching habits are automatically completed based on user-defined mappings.
  </action>
  <verify>
```bash
# Check matchAndCompleteHabits is called
grep -n "matchAndCompleteHabits" src/app/api/integrations/health-import/webhook/route.ts

# Build check
npm run build 2>&1 | head -30
```
  </verify>
  <done>Webhook calls matchAndCompleteHabits for each imported workout</done>
</task>

<task type="auto">
  <name>Task 6: Integrate HabitHealthMappingConfig into settings page</name>
  <files>src/app/(protected)/settings/integrations/page.tsx</files>
  <action>
Add the HabitHealthMappingConfig component to the health/integrations settings page.

1. Add import at top of file:
```typescript
import { HabitHealthMappingConfig } from '@/components/health-import/HabitHealthMapping';
```

2. Add the component to the settings page layout. If there's an existing health import section, add it there. Otherwise, create a new section:
```typescript
{/* Health Import Mappings Section */}
<section className="mt-8">
  <HabitHealthMappingConfig />
</section>
```

If the integrations settings page doesn't exist yet, the component should be added to whichever settings page handles health import configuration (e.g., `src/app/(protected)/settings/health/page.tsx` or similar).

The component allows users to configure which workout types auto-complete which habits.
  </action>
  <verify>
```bash
# Check import was added (try multiple possible locations)
grep -rn "HabitHealthMappingConfig" src/app/\(protected\)/settings/

# Build check
npm run build 2>&1 | head -30
```
  </verify>
  <done>HabitHealthMappingConfig is accessible from settings and users can configure mappings</done>
</task>

</tasks>

<verification>
1. Migration file creates habit_health_mappings table with unique constraint
2. Health import data layer has matchAndCompleteHabits function
3. Function checks for existing completion before auto-completing
4. API endpoints handle CRUD for mappings with proper auth
5. UI component allows adding and removing mappings
6. Webhook route.ts imports and calls matchAndCompleteHabits
7. HabitHealthMappingConfig is imported and rendered in settings page
8. TypeScript compiles without errors: `npm run build`
</verification>

<success_criteria>
- [ ] Database migration creates habit_health_mappings with indexes
- [ ] matchAndCompleteHabits function matches workouts to habits
- [ ] Function prevents duplicate habit completions on same day
- [ ] API endpoint GET returns mappings with habit info
- [ ] API endpoint POST creates mapping with validation
- [ ] API endpoint DELETE removes mapping
- [ ] UI component displays existing mappings
- [ ] UI component allows creating new mappings
- [ ] Health import webhook calls matchAndCompleteHabits after processing workouts
- [ ] HabitHealthMappingConfig is accessible from settings page
- [ ] All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-fairness-proaktivitaet/01-03-SUMMARY.md`
</output>
