---
phase: 01-fairness-proaktivitaet
plan: 02
type: execute
wave: 2
depends_on: []
files_modified:
  - supabase/migrations/20260201_proactive_notification_log.sql
  - src/lib/cron/proactive-scheduler.ts
  - src/instrumentation.ts
  - src/lib/types/notifications.ts
autonomous: true

must_haves:
  truths:
    - "Users receive 1 proactive notification per day about neglected factions"
    - "Notifications respect quiet hours settings"
    - "No duplicate notifications sent on same day"
    - "Notification includes faction name and days since last activity"
  artifacts:
    - path: "supabase/migrations/20260201_proactive_notification_log.sql"
      provides: "Database table for notification deduplication"
      contains: "CREATE TABLE proactive_notification_log"
    - path: "src/lib/cron/proactive-scheduler.ts"
      provides: "Cron job for proactive reminders"
      exports: ["initProactiveScheduler"]
    - path: "src/instrumentation.ts"
      provides: "Server initialization with new scheduler"
      contains: "initProactiveScheduler"
  key_links:
    - from: "src/lib/cron/proactive-scheduler.ts"
      to: "user_faction_stats"
      via: "supabase query"
      pattern: "from.*user_faction_stats"
    - from: "src/instrumentation.ts"
      to: "src/lib/cron/proactive-scheduler.ts"
      via: "dynamic import"
      pattern: "import.*proactive-scheduler"
---

<objective>
Implement Proactive Life-Domain Reminders that notify users about neglected factions.

Purpose: Make the app "alive" by proactively engaging users. When a user hasn't interacted with a life domain (faction) for 7+ days, send a gentle reminder to re-engage. This prevents users from forgetting about important life areas.

Output:
- Database table for tracking sent notifications
- Cron scheduler that runs daily
- Integration with existing notification infrastructure
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-fairness-proaktivitaet/01-RESEARCH.md

Key existing patterns:
- Cron infrastructure: `src/lib/cron/reminder-scheduler.ts`
- Server initialization: `src/instrumentation.ts`
- Notification settings: `src/lib/data/notifications.ts`
- Faction data: `src/lib/data/factions.ts`
- Web Push: Configured with VAPID in reminder-scheduler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for proactive_notification_log</name>
  <files>supabase/migrations/20260201_proactive_notification_log.sql</files>
  <action>
Create migration file:

```sql
-- Proactive Notification Log
-- Tracks sent proactive notifications to prevent duplicates

CREATE TABLE IF NOT EXISTS proactive_notification_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  faction_id TEXT NOT NULL,
  notification_type TEXT NOT NULL DEFAULT 'neglected_faction',
  sent_at TIMESTAMPTZ DEFAULT NOW(),
  clicked BOOLEAN DEFAULT FALSE,
  clicked_at TIMESTAMPTZ,

  -- Metadata
  days_neglected INTEGER,
  channel TEXT CHECK (channel IN ('push', 'telegram'))
);

-- Index for fast lookup
CREATE INDEX idx_proactive_log_user ON proactive_notification_log(user_id);
CREATE INDEX idx_proactive_log_date ON proactive_notification_log(user_id, DATE(sent_at));

-- Prevent duplicate notifications on same day for same faction
CREATE UNIQUE INDEX idx_proactive_daily_faction
  ON proactive_notification_log(user_id, faction_id, DATE(sent_at));

-- RLS policies
ALTER TABLE proactive_notification_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own notification log" ON proactive_notification_log
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Service can insert notifications" ON proactive_notification_log
  FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update own notifications" ON proactive_notification_log
  FOR UPDATE USING (auth.uid() = user_id);

COMMENT ON TABLE proactive_notification_log IS 'Tracks proactive notifications sent to users about neglected life domains';
```
  </action>
  <verify>
```bash
cat supabase/migrations/20260201_proactive_notification_log.sql
```
  </verify>
  <done>Migration file exists with deduplication logic via unique index on (user_id, faction_id, DATE(sent_at))</done>
</task>

<task type="auto">
  <name>Task 2: Create proactive scheduler cron job</name>
  <files>src/lib/cron/proactive-scheduler.ts</files>
  <action>
Create the scheduler following the existing reminder-scheduler.ts pattern:

```typescript
// ============================================
// Projekt L - Proactive Faction Reminder Scheduler
// Notifies users about neglected life domains
// ============================================

import cron from 'node-cron';
import { createClient } from '@supabase/supabase-js';
import webpush from 'web-push';

// Configure web-push lazily
let vapidConfigured = false;
function ensureVapidConfigured() {
  if (!vapidConfigured && process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY && process.env.VAPID_PRIVATE_KEY) {
    webpush.setVapidDetails(
      process.env.VAPID_SUBJECT || 'mailto:lukas@projekt-l.de',
      process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY,
      process.env.VAPID_PRIVATE_KEY
    );
    vapidConfigured = true;
  }
}

// Supabase client with service role
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// Faction metadata for notifications
const FACTION_META: Record<string, { name: string; icon: string }> = {
  karriere: { name: 'Karriere', icon: 'ðŸ’¼' },
  hobbys: { name: 'Hobbys', icon: 'ðŸŽ¨' },
  koerper: { name: 'Koerper', icon: 'ðŸ’ª' },
  geist: { name: 'Geist', icon: 'ðŸ§ ' },
  finanzen: { name: 'Finanzen', icon: 'ðŸ’°' },
  soziales: { name: 'Soziales', icon: 'ðŸ‘¥' },
  weisheit: { name: 'Weisheit', icon: 'ðŸ“š' },
};

const NEGLECT_THRESHOLD_DAYS = 7;

interface UserWithSettings {
  user_id: string;
  push_subscription: any;
  telegram_chat_id: string | null;
  telegram_enabled: boolean;
  timezone: string;
  quiet_hours_enabled: boolean;
  quiet_hours_start: string;
  quiet_hours_end: string;
}

interface NeglectedFaction {
  faction_id: string;
  last_activity: string | null;
  days_neglected: number;
}

/**
 * Check if current time is within quiet hours for user
 */
function isQuietHours(settings: UserWithSettings): boolean {
  if (!settings.quiet_hours_enabled) return false;

  const now = new Date();
  const currentTime = now.toLocaleTimeString('de-DE', {
    timeZone: settings.timezone || 'Europe/Berlin',
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  });

  const start = settings.quiet_hours_start || '22:00';
  const end = settings.quiet_hours_end || '08:00';

  // Handle overnight quiet hours (e.g., 22:00 - 08:00)
  if (start > end) {
    return currentTime >= start || currentTime < end;
  }

  return currentTime >= start && currentTime < end;
}

/**
 * Find the most neglected faction for a user
 */
async function findNeglectedFaction(userId: string): Promise<NeglectedFaction | null> {
  const { data, error } = await supabase
    .from('user_faction_stats')
    .select('faction_id, last_activity')
    .eq('user_id', userId)
    .order('last_activity', { ascending: true, nullsFirst: true })
    .limit(1)
    .single();

  if (error || !data) return null;

  const lastActivity = data.last_activity ? new Date(data.last_activity) : null;
  const daysNeglected = lastActivity
    ? Math.floor((Date.now() - lastActivity.getTime()) / (1000 * 60 * 60 * 24))
    : 999; // Never active

  if (daysNeglected < NEGLECT_THRESHOLD_DAYS) return null;

  return {
    faction_id: data.faction_id,
    last_activity: data.last_activity,
    days_neglected: daysNeglected,
  };
}

/**
 * Check if user was already notified today
 */
async function wasNotifiedToday(userId: string): Promise<boolean> {
  const today = new Date().toISOString().split('T')[0];

  const { data } = await supabase
    .from('proactive_notification_log')
    .select('id')
    .eq('user_id', userId)
    .gte('sent_at', today)
    .limit(1)
    .single();

  return !!data;
}

/**
 * Send push notification
 */
async function sendPushNotification(
  userId: string,
  subscription: any,
  faction: NeglectedFaction
): Promise<boolean> {
  const meta = FACTION_META[faction.faction_id] || { name: faction.faction_id, icon: 'ðŸ“Š' };

  const payload = JSON.stringify({
    title: `${meta.icon} ${meta.name} braucht Aufmerksamkeit!`,
    body: `Du hast seit ${faction.days_neglected} Tagen keine ${meta.name}-Aktivitaet. Zeit fuer ein Habit oder Quest?`,
    url: `/dashboard?highlight=${faction.faction_id}`,
    tag: `proactive-faction-${faction.faction_id}`,
    renotify: false,
    data: {
      type: 'proactive_faction',
      factionId: faction.faction_id,
    },
  });

  try {
    ensureVapidConfigured();
    await webpush.sendNotification(subscription, payload);

    // Log successful delivery
    await supabase.from('proactive_notification_log').insert({
      user_id: userId,
      faction_id: faction.faction_id,
      notification_type: 'neglected_faction',
      days_neglected: faction.days_neglected,
      channel: 'push',
    });

    console.log(`[Proactive Scheduler] Sent push for ${meta.name} to user ${userId}`);
    return true;
  } catch (error: any) {
    console.error('[Proactive Scheduler] Push error:', error);

    // Handle expired subscription
    if (error.statusCode === 410 || error.statusCode === 404) {
      await supabase
        .from('notification_settings')
        .update({ push_enabled: false, push_subscription: null })
        .eq('user_id', userId);
    }
    return false;
  }
}

/**
 * Main function to check and send proactive reminders
 */
async function checkProactiveReminders(): Promise<void> {
  try {
    console.log('[Proactive Scheduler] Starting daily check...');

    // Get all users with push enabled
    const { data: users, error } = await supabase
      .from('notification_settings')
      .select(`
        user_id,
        push_subscription,
        telegram_chat_id,
        telegram_enabled,
        quiet_hours_enabled,
        quiet_hours_start,
        quiet_hours_end,
        user_profiles!inner (
          timezone
        )
      `)
      .eq('push_enabled', true)
      .not('push_subscription', 'is', null);

    if (error) {
      console.error('[Proactive Scheduler] Error fetching users:', error);
      return;
    }

    if (!users || users.length === 0) {
      console.log('[Proactive Scheduler] No users with push enabled');
      return;
    }

    console.log(`[Proactive Scheduler] Checking ${users.length} users...`);

    let notificationsSent = 0;

    for (const user of users) {
      try {
        const settings: UserWithSettings = {
          user_id: user.user_id,
          push_subscription: user.push_subscription,
          telegram_chat_id: user.telegram_chat_id,
          telegram_enabled: user.telegram_enabled,
          timezone: (user.user_profiles as any)?.timezone || 'Europe/Berlin',
          quiet_hours_enabled: user.quiet_hours_enabled,
          quiet_hours_start: user.quiet_hours_start,
          quiet_hours_end: user.quiet_hours_end,
        };

        // Skip if in quiet hours
        if (isQuietHours(settings)) {
          continue;
        }

        // Skip if already notified today
        if (await wasNotifiedToday(user.user_id)) {
          continue;
        }

        // Find neglected faction
        const neglectedFaction = await findNeglectedFaction(user.user_id);
        if (!neglectedFaction) {
          continue;
        }

        // Send notification
        const sent = await sendPushNotification(
          user.user_id,
          user.push_subscription,
          neglectedFaction
        );

        if (sent) {
          notificationsSent++;
        }
      } catch (err) {
        console.error(`[Proactive Scheduler] Error processing user ${user.user_id}:`, err);
      }
    }

    console.log(`[Proactive Scheduler] Check complete. Sent ${notificationsSent} notifications.`);
  } catch (error) {
    console.error('[Proactive Scheduler] Fatal error:', error);
  }
}

/**
 * Initialize the proactive reminder scheduler
 */
export function initProactiveScheduler(): void {
  // Run at 10:00 AM every day (server time)
  // Users will receive at appropriate local times due to quiet hours check
  cron.schedule('0 10 * * *', () => {
    checkProactiveReminders();
  });

  console.log('[Proactive Scheduler] âœ… Initialized - Running daily at 10:00');
}
```
  </action>
  <verify>
```bash
# Check file exists
cat src/lib/cron/proactive-scheduler.ts | head -50

# TypeScript check
npm run build 2>&1 | grep -i "proactive" | head -10
```
  </verify>
  <done>Proactive scheduler exports initProactiveScheduler function and follows reminder-scheduler pattern</done>
</task>

<task type="auto">
  <name>Task 3: Integrate scheduler into instrumentation.ts</name>
  <files>src/instrumentation.ts</files>
  <action>
Update instrumentation.ts to include the new proactive scheduler:

```typescript
// ============================================
// Projekt L - Server Instrumentation
// Runs ONCE when Next.js server starts
// ============================================

export async function register() {
  // Only run on Node.js server, not in Edge runtime
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    const { initReminderScheduler } = await import('./lib/cron/reminder-scheduler');
    const { initProactiveScheduler } = await import('./lib/cron/proactive-scheduler');

    console.log('[Instrumentation] Server starting...');
    console.log('[Instrumentation] Initializing schedulers...');

    initReminderScheduler();
    initProactiveScheduler();

    console.log('[Instrumentation] All schedulers initialized âœ…');
  }
}
```

Note: Keep existing imports, just add the new scheduler import and initialization call.
  </action>
  <verify>
```bash
# Check instrumentation includes new scheduler
grep -n "proactive" src/instrumentation.ts

# Build check
npm run build 2>&1 | head -30
```
  </verify>
  <done>instrumentation.ts imports and initializes proactive scheduler alongside existing scheduler</done>
</task>

</tasks>

<verification>
1. Migration file has valid SQL with unique index for deduplication
2. Proactive scheduler follows existing reminder-scheduler pattern
3. Scheduler respects quiet hours via isQuietHours function
4. Scheduler checks wasNotifiedToday before sending
5. instrumentation.ts initializes both schedulers
6. TypeScript compiles without errors: `npm run build`
</verification>

<success_criteria>
- [ ] Database migration creates proactive_notification_log with deduplication index
- [ ] Proactive scheduler runs daily at 10:00 via cron
- [ ] Scheduler finds users with neglected factions (7+ days)
- [ ] Scheduler respects quiet hours settings
- [ ] Scheduler prevents duplicate notifications via log check
- [ ] Push notifications include faction name and days neglected
- [ ] Notifications are logged to proactive_notification_log
- [ ] All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-fairness-proaktivitaet/01-02-SUMMARY.md`
</output>
