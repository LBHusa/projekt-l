---
phase: 02-api-security-audit
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - tests/e2e/api-security.spec.ts
autonomous: true

must_haves:
  truths:
    - "E2E tests verify unauthenticated requests return 401"
    - "E2E tests verify error responses don't leak sensitive data"
    - "E2E tests verify Health Import webhook rejects invalid API keys"
    - "All Phase 2 success criteria are testable via E2E tests"
  artifacts:
    - path: "tests/e2e/api-security.spec.ts"
      provides: "API security E2E tests"
      min_lines: 80
      contains: "test.describe('API Security'"
  key_links:
    - from: "tests/e2e/api-security.spec.ts"
      to: "API routes"
      via: "fetch requests"
      pattern: "fetch.*api/"
---

<objective>
Create E2E tests that verify Phase 2 security requirements (SEC-04, SEC-08, SEC-09, SEC-10).

Purpose: Validate that authentication is enforced, error messages are sanitized, and webhook security is working. These tests serve as regression tests to prevent future security regressions.

Output: Playwright test file with tests for all Phase 2 success criteria.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-security-audit/02-RESEARCH.md
@.planning/phases/02-api-security-audit/02-01-SUMMARY.md
@tests/e2e/security-validation.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API security E2E tests</name>
  <files>tests/e2e/api-security.spec.ts</files>
  <action>
    Create a new Playwright test file for API security validation.

    ```typescript
    import { test, expect } from '@playwright/test';

    /**
     * API Security Tests - Phase 2
     *
     * Validates:
     * - SEC-04: Unauthenticated users redirected to login
     * - SEC-08: API routes return 401 without valid session
     * - SEC-09: Health Import webhook validates API key
     * - SEC-10: Error responses don't leak sensitive data
     */

    test.describe('API Security - Authentication (SEC-04, SEC-08)', () => {

      test('Unauthenticated API request returns 401', async ({ request }) => {
        // Test multiple protected endpoints without auth
        const protectedEndpoints = [
          { method: 'GET', url: '/api/quests' },
          { method: 'GET', url: '/api/habits/list' },
          { method: 'GET', url: '/api/skills' },
          { method: 'GET', url: '/api/user/profile' },
        ];

        for (const endpoint of protectedEndpoints) {
          const response = await request.fetch(endpoint.url, {
            method: endpoint.method,
          });

          expect(response.status()).toBe(401);

          const body = await response.json();
          expect(body.error).toBe('Unauthorized');
        }
      });

      test('Unauthenticated POST request returns 401', async ({ request }) => {
        const response = await request.post('/api/quests', {
          data: { title: 'Test Quest', description: 'Test' },
        });

        expect(response.status()).toBe(401);
      });

      test('Protected pages redirect to login when unauthenticated', async ({ page, context }) => {
        // Clear any existing auth state
        await context.clearCookies();

        const protectedPages = [
          '/quests',
          '/habits',
          '/skills',
          '/profile',
          '/soziales',
          '/karriere',
        ];

        for (const pagePath of protectedPages) {
          await page.goto(pagePath);
          // Should redirect to login
          await expect(page).toHaveURL(/\/auth\/login|\/login/);
        }
      });

    });

    test.describe('API Security - Error Sanitization (SEC-10)', () => {

      test('Error responses do not contain stack traces', async ({ request }) => {
        // Send malformed request to trigger error
        const response = await request.post('/api/habits/create', {
          data: { invalid_field: 'should cause error' },
          headers: {
            'Content-Type': 'application/json',
          },
        });

        // Should return 400 (validation) or 401 (auth), not 500 with stack trace
        const body = await response.json();
        const bodyStr = JSON.stringify(body);

        // Error response should not contain:
        expect(bodyStr).not.toContain('at ');  // Stack trace pattern
        expect(bodyStr).not.toContain('.ts:');  // File paths
        expect(bodyStr).not.toContain('node_modules');
        expect(bodyStr).not.toContain('POSTGRES');
        expect(bodyStr).not.toContain('supabase');
      });

      test('Error responses use generic messages', async ({ page }) => {
        // Login first to test authenticated error responses
        // Auth is handled by auth.setup.ts

        // Intercept API responses
        const errorResponses: string[] = [];
        page.on('response', async (response) => {
          if (response.url().includes('/api/') && response.status() === 500) {
            try {
              const body = await response.json();
              errorResponses.push(JSON.stringify(body));
            } catch {
              // Non-JSON response
            }
          }
        });

        // Navigate to trigger API calls
        await page.goto('/habits');
        await page.waitForLoadState('networkidle');

        // Any 500 errors should have generic messages
        for (const errorBody of errorResponses) {
          // Should contain generic message, not internal details
          expect(errorBody).not.toMatch(/duplicate key|constraint|column|table/i);
        }
      });

      test('Validation errors return structured response without internals', async ({ request }) => {
        // This test needs auth - use page context for auth
        // For now, test that validation errors are properly formatted

        const response = await request.post('/api/quests', {
          data: {
            title: '', // Empty title should fail validation
          },
        });

        // Should be 400 (validation) or 401 (auth)
        expect([400, 401]).toContain(response.status());

        if (response.status() === 400) {
          const body = await response.json();
          // Validation errors can include field names but not stack traces
          expect(body).toHaveProperty('error');
          expect(JSON.stringify(body)).not.toContain('at ');
        }
      });

    });

    test.describe('API Security - Webhook Auth (SEC-09)', () => {

      test('Health Import webhook rejects missing authorization', async ({ request }) => {
        const response = await request.post('/api/integrations/health-import/webhook', {
          data: {
            type: 'health_metrics',
            data: { steps: 5000 },
          },
        });

        expect(response.status()).toBe(401);

        const body = await response.json();
        expect(body.error).toContain('Authorization');
      });

      test('Health Import webhook rejects invalid API key', async ({ request }) => {
        const response = await request.post('/api/integrations/health-import/webhook', {
          headers: {
            'Authorization': 'Bearer invalid_api_key_12345',
          },
          data: {
            type: 'health_metrics',
            data: { steps: 5000 },
          },
        });

        expect(response.status()).toBe(401);

        const body = await response.json();
        expect(body.error).toContain('Invalid');
      });

      test('Health Import webhook health check is public', async ({ request }) => {
        // GET request is a health check and should be public
        const response = await request.get('/api/integrations/health-import/webhook');

        // Should return 200 or 405 (method not allowed), not 401
        expect([200, 405]).toContain(response.status());
      });

    });

    test.describe('API Security - Service Role Protection', () => {

      test('Cannot bypass auth by spoofing user ID in request body', async ({ request }) => {
        // Attempt to create a habit for a different user
        const response = await request.post('/api/habits/create', {
          data: {
            name: 'Malicious Habit',
            user_id: '00000000-0000-0000-0000-000000000001', // Spoofed user ID
          },
        });

        // Should be rejected (401 no auth, or user_id ignored)
        expect(response.status()).toBe(401);
      });

    });
    ```

    Key test coverage:
    - SEC-04: Protected page redirect tests
    - SEC-08: API route 401 tests
    - SEC-09: Webhook API key validation
    - SEC-10: Error message sanitization

    Note: Some tests require authenticated context. Use the auth.setup.ts pattern from security-validation.spec.ts if needed for authenticated tests.
  </action>
  <verify>
    Run the new tests:
    `npx playwright test tests/e2e/api-security.spec.ts --reporter=list`
    Should see tests pass (or expected failures for auth-required tests).
  </verify>
  <done>API security E2E tests created covering all Phase 2 requirements</done>
</task>

<task type="auto">
  <name>Task 2: Run full security test suite and document results</name>
  <files>None (verification only)</files>
  <action>
    Run the complete security test suite to verify Phase 2 requirements:

    ```bash
    # Run all security-related E2E tests
    npx playwright test tests/e2e/security-validation.spec.ts tests/e2e/api-security.spec.ts --reporter=list

    # Check for any remaining error.message leakage
    grep -rn "error\.message" src/app/api/ --include="*.ts" | grep -v "test/" | grep -v "console" | head -20
    ```

    Document the test results:
    - Number of tests passing
    - Number of tests failing (if any)
    - Any tests that need adjustment

    If any tests fail due to authentication setup issues:
    - Note them as "requires auth setup" in the summary
    - These will be addressed in Phase 3 (E2E Testing Infrastructure)

    Verify Phase 2 success criteria:
    1. Unauthenticated user redirected to login (SEC-04) - tested by redirect tests
    2. API routes return 401 without session (SEC-08) - tested by 401 tests
    3. Health Import webhook validates API key (SEC-09) - tested by webhook tests
    4. Error messages don't leak sensitive data (SEC-10) - tested by error sanitization tests
  </action>
  <verify>
    All tests pass or fail with expected reasons:
    - Auth-required tests may fail until Phase 3 sets up proper test auth
    - Unauthenticated tests should all pass
    - Error sanitization tests should pass after 02-01
  </verify>
  <done>Security test suite executed and results documented</done>
</task>

</tasks>

<verification>
1. Test file exists and has expected structure:
   `head -50 tests/e2e/api-security.spec.ts`

2. Tests can be parsed (no syntax errors):
   `npx playwright test tests/e2e/api-security.spec.ts --list`

3. Run tests and capture results:
   `npx playwright test tests/e2e/api-security.spec.ts --reporter=list 2>&1 | tail -20`

4. Verify Phase 2 requirements are covered by tests:
   - SEC-04: "redirect to login" test exists
   - SEC-08: "returns 401" test exists
   - SEC-09: "webhook rejects" tests exist
   - SEC-10: "stack traces", "generic messages" tests exist
</verification>

<success_criteria>
- tests/e2e/api-security.spec.ts created with 8+ tests
- Tests cover all 4 Phase 2 requirements (SEC-04, SEC-08, SEC-09, SEC-10)
- Tests can be run without syntax errors
- Unauthenticated tests pass
- Error sanitization tests pass (after 02-01)
- Test results documented in summary
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-security-audit/02-02-SUMMARY.md`
</output>
