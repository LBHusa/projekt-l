---
phase: 02-konsequenzen-hp-death
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260202_001_hp_system_schema.sql
  - src/lib/database.types.ts
autonomous: true

must_haves:
  truths:
    - "User has HP state persisted in database (100/100 HP, 3/3 lives)"
    - "HP changes are logged in append-only health_events table"
    - "HP updates are atomic (no race conditions possible)"
    - "Death detection triggers automatically when HP reaches 0"
  artifacts:
    - path: "supabase/migrations/20260202_001_hp_system_schema.sql"
      provides: "user_health + health_events tables with RLS policies"
      min_lines: 150
    - path: "src/lib/database.types.ts"
      provides: "TypeScript types for health tables"
      contains: "UserHealth"
  key_links:
    - from: "apply_hp_change RPC function"
      to: "user_health.current_hp"
      via: "atomic UPDATE with LEAST/GREATEST bounds"
      pattern: "LEAST\\(max_hp, GREATEST\\(0, current_hp"
    - from: "apply_hp_change RPC"
      to: "health_events INSERT"
      via: "logs death event when HP drops to 0"
      pattern: "event_type.*death"
---

<objective>
Create database foundation for HP/Death system with user_health and health_events tables.

Purpose: Establish the core data model for health tracking with atomic HP updates, death detection, and comprehensive event logging. This is the foundational layer that all damage/heal triggers will depend on.

Output: Migration file with tables, RLS policies, indexes, and apply_hp_change RPC function that handles atomic HP updates with death detection.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/root/husatech/projekt-l/.planning/PROJECT.md
@/root/husatech/projekt-l/.planning/ROADMAP.md
@/root/husatech/projekt-l/.planning/STATE.md
@/root/husatech/projekt-l/.planning/phases/02-konsequenzen-hp-death/02-RESEARCH.md

# Existing patterns
@/root/husatech/projekt-l/supabase/migrations/20260201_streak_insurance_tokens.sql
@/root/husatech/projekt-l/src/lib/data/factions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HP System Schema Migration</name>
  <files>supabase/migrations/20260202_001_hp_system_schema.sql</files>
  <action>
Create migration file following existing pattern from streak_insurance_tokens.sql.

**Create user_health table:**
- id UUID PRIMARY KEY (gen_random_uuid)
- user_id UUID UNIQUE REFERENCES auth.users ON DELETE CASCADE
- current_hp INTEGER NOT NULL DEFAULT 100
- max_hp INTEGER NOT NULL DEFAULT 100
- lives INTEGER NOT NULL DEFAULT 3
- max_lives INTEGER NOT NULL DEFAULT 3
- awaiting_prestige BOOLEAN DEFAULT FALSE
- prestige_level INTEGER DEFAULT 0
- created_at TIMESTAMPTZ DEFAULT NOW()
- updated_at TIMESTAMPTZ DEFAULT NOW()

**Create health_events table (append-only log):**
- id UUID PRIMARY KEY (gen_random_uuid)
- user_id UUID NOT NULL REFERENCES auth.users ON DELETE CASCADE
- event_type TEXT NOT NULL (quest_complete, habit_done, streak_break, inactivity, death, prestige)
- hp_change INTEGER NOT NULL (positive = heal, negative = damage)
- source_table TEXT (quests, habits, habit_logs, NULL for system)
- source_id UUID (ID of quest/habit/log)
- metadata JSONB (difficulty, days_inactive, etc.)
- created_at TIMESTAMPTZ DEFAULT NOW()

**Indexes for performance:**
- idx_user_health_user ON user_health(user_id)
- idx_health_events_user ON health_events(user_id)
- idx_health_events_type ON health_events(event_type)
- idx_health_events_created ON health_events(created_at DESC)

**RLS Policies:**
- Enable RLS on both tables
- SELECT policy: Users can view own health/events (auth.uid() = user_id)
- No INSERT/UPDATE/DELETE policies (only via RPC functions and triggers)

**apply_hp_change RPC function:**
- Parameters: p_user_id UUID, p_hp_change INTEGER
- Logic:
  1. Lock user_health row FOR UPDATE (prevent race conditions)
  2. Calculate new_hp = LEAST(max_hp, GREATEST(0, current_hp + p_hp_change))
  3. Check if death occurred (current_hp > 0 AND new_hp = 0)
  4. If death: Respawn at full HP, decrement lives, INSERT death event
  5. Else: Normal HP update
  6. UPDATE user_health with new values
- Return: void
- Use LANGUAGE plpgsql

Follow patterns from Phase 1 migrations (RLS, indexes, foreign keys).
  </action>
  <verify>
```bash
# Apply migration
cd /root/husatech/projekt-l
npx supabase db reset --local

# Check tables exist
npx supabase db query "SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_name IN ('user_health', 'health_events');"

# Test RPC function
npx supabase db query "SELECT apply_hp_change('00000000-0000-0000-0000-000000000000'::uuid, -50);"
```
  </verify>
  <done>
- user_health table exists with 10 columns
- health_events table exists with 7 columns
- 4 indexes created (user, type, created)
- RLS policies enabled (SELECT only)
- apply_hp_change RPC function exists and handles death detection
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate TypeScript Types</name>
  <files>src/lib/database.types.ts</files>
  <action>
Add TypeScript types for new tables to database.types.ts following existing pattern.

**Add to Database interface:**
```typescript
user_health: {
  Row: {
    id: string;
    user_id: string;
    current_hp: number;
    max_hp: number;
    lives: number;
    max_lives: number;
    awaiting_prestige: boolean;
    prestige_level: number;
    created_at: string;
    updated_at: string;
  };
  Insert: {
    id?: string;
    user_id: string;
    current_hp?: number;
    max_hp?: number;
    lives?: number;
    max_lives?: number;
    awaiting_prestige?: boolean;
    prestige_level?: number;
    created_at?: string;
    updated_at?: string;
  };
  Update: {
    id?: string;
    user_id?: string;
    current_hp?: number;
    max_hp?: number;
    lives?: number;
    max_lives?: number;
    awaiting_prestige?: boolean;
    prestige_level?: number;
    created_at?: string;
    updated_at?: string;
  };
};
health_events: {
  Row: {
    id: string;
    user_id: string;
    event_type: string;
    hp_change: number;
    source_table: string | null;
    source_id: string | null;
    metadata: Json | null;
    created_at: string;
  };
  Insert: {
    id?: string;
    user_id: string;
    event_type: string;
    hp_change: number;
    source_table?: string | null;
    source_id?: string | null;
    metadata?: Json | null;
    created_at?: string;
  };
  Update: {
    id?: string;
    user_id?: string;
    event_type?: string;
    hp_change?: number;
    source_table?: string | null;
    source_id?: string | null;
    metadata?: Json | null;
    created_at?: string;
  };
};
```

**Export convenience types:**
```typescript
export type UserHealth = Database['public']['Tables']['user_health']['Row'];
export type HealthEvent = Database['public']['Tables']['health_events']['Row'];
```

Maintain alphabetical order in Tables section, follow existing formatting.
  </action>
  <verify>
```bash
# TypeScript compilation check
cd /root/husatech/projekt-l
npm run build 2>&1 | grep -i "error" && echo "ERRORS FOUND" || echo "BUILD SUCCESS"
```
  </verify>
  <done>
- UserHealth and HealthEvent types exported
- No TypeScript compilation errors
- Types match migration schema exactly
  </done>
</task>

</tasks>

<verification>
**Database schema checks:**
```sql
-- Verify user_health constraints
SELECT column_name, data_type, is_nullable, column_default
FROM information_schema.columns
WHERE table_name = 'user_health';

-- Verify health_events structure
SELECT column_name, data_type
FROM information_schema.columns
WHERE table_name = 'health_events';

-- Test apply_hp_change with death scenario
DO $$
DECLARE
  test_user_id UUID := gen_random_uuid();
BEGIN
  INSERT INTO user_health (user_id, current_hp, lives) VALUES (test_user_id, 10, 3);
  PERFORM apply_hp_change(test_user_id, -20); -- Should cause death

  ASSERT (SELECT lives FROM user_health WHERE user_id = test_user_id) = 2, 'Lives should decrement on death';
  ASSERT (SELECT current_hp FROM user_health WHERE user_id = test_user_id) = 100, 'HP should respawn at full';
  ASSERT (SELECT COUNT(*) FROM health_events WHERE user_id = test_user_id AND event_type = 'death') = 1, 'Death event logged';
END $$;
```

**TypeScript type checks:**
```typescript
// Verify types compile
import type { UserHealth, HealthEvent } from '@/lib/database.types';

const health: UserHealth = {
  id: '',
  user_id: '',
  current_hp: 100,
  max_hp: 100,
  lives: 3,
  max_lives: 3,
  awaiting_prestige: false,
  prestige_level: 0,
  created_at: '',
  updated_at: ''
};
```
</verification>

<success_criteria>
**Must be true after completion:**
- [ ] user_health table exists with RLS enabled
- [ ] health_events table exists with RLS enabled
- [ ] apply_hp_change RPC function handles atomic updates
- [ ] Death detection works (HP=0 triggers respawn + life loss)
- [ ] TypeScript types match schema exactly
- [ ] No TypeScript compilation errors
- [ ] Migration applies cleanly (npx supabase db reset)
</success_criteria>

<output>
After completion, create `.planning/phases/02-konsequenzen-hp-death/02-01-SUMMARY.md`
</output>
