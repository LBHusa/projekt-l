---
phase: 02-konsequenzen-hp-death
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - supabase/migrations/20260202_002_hp_damage_triggers.sql
  - src/app/api/habits/relapse/route.ts
  - src/instrumentation.ts
  - src/app/api/health/inactivity-check/route.ts
autonomous: true

must_haves:
  truths:
    - "Quest failure applies -10 HP automatically via database trigger"
    - "Habit streak break applies -5 HP via application logic"
    - "3+ days inactivity applies -5 HP per day via daily cron"
  artifacts:
    - path: "supabase/migrations/20260202_002_hp_damage_triggers.sql"
      provides: "Quest failure trigger"
      contains: "CREATE TRIGGER quest_failure_hp_trigger"
    - path: "src/app/api/habits/relapse/route.ts"
      provides: "Streak break HP damage"
      contains: "health_events.*streak_break"
    - path: "src/instrumentation.ts"
      provides: "Daily inactivity cron scheduler"
      contains: "healthInactivityScheduler"
    - path: "src/app/api/health/inactivity-check/route.ts"
      provides: "Inactivity damage calculation"
      exports: ["POST"]
  key_links:
    - from: "quests.status UPDATE to 'failed'"
      to: "apply_hp_change(-10)"
      via: "PostgreSQL AFTER trigger"
      pattern: "handle_quest_failure_hp"
    - from: "habits/relapse API"
      to: "apply_hp_change(-5)"
      via: "RPC call after streak reset"
      pattern: "rpc\\('apply_hp_change'"
    - from: "instrumentation.ts cron"
      to: "/api/health/inactivity-check"
      via: "daily fetch at 3 AM"
      pattern: "0 3 \\* \\* \\*"
---

<objective>
Implement all HP damage triggers that create consequences for user inaction.

Purpose: Make the HP system responsive to negative events (quest failures, streak breaks, inactivity). This creates the "stakes" that motivate users to maintain consistency and complete commitments.

Output: Database trigger for quest failures, application-level damage logic for streak breaks, and daily cron scheduler for inactivity penalties.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/root/husatech/projekt-l/.planning/PROJECT.md
@/root/husatech/projekt-l/.planning/ROADMAP.md
@/root/husatech/projekt-l/.planning/STATE.md
@/root/husatech/projekt-l/.planning/phases/02-konsequenzen-hp-death/02-RESEARCH.md
@/root/husatech/projekt-l/.planning/phases/02-konsequenzen-hp-death/02-01-SUMMARY.md
@/root/husatech/projekt-l/.planning/phases/02-konsequenzen-hp-death/02-02-SUMMARY.md

# Pattern references
@/root/husatech/projekt-l/src/app/api/habits/relapse/route.ts
@/root/husatech/projekt-l/src/instrumentation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Quest Failure HP Trigger</name>
  <files>supabase/migrations/20260202_002_hp_damage_triggers.sql</files>
  <action>
Create new migration file for damage triggers (separate from schema for clarity).

**Quest Failure Trigger:**
```sql
-- Trigger function for quest failure HP damage
CREATE OR REPLACE FUNCTION handle_quest_failure_hp()
RETURNS TRIGGER AS $$
BEGIN
  -- Only trigger on status change to 'failed'
  IF NEW.status = 'failed' AND (OLD.status IS NULL OR OLD.status != 'failed') THEN
    -- Log damage event
    INSERT INTO health_events (
      user_id,
      event_type,
      hp_change,
      source_table,
      source_id,
      metadata
    ) VALUES (
      NEW.user_id,
      'quest_failed',
      -10,
      'quests',
      NEW.id,
      jsonb_build_object('title', NEW.title, 'difficulty', NEW.difficulty)
    );

    -- Apply HP damage
    PERFORM apply_hp_change(NEW.user_id, -10);
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger on quests table
CREATE TRIGGER quest_failure_hp_trigger
AFTER UPDATE ON quests
FOR EACH ROW
EXECUTE FUNCTION handle_quest_failure_hp();
```

**Key considerations:**
- Only trigger on NEW.status = 'failed' AND OLD.status != 'failed' to prevent duplicate damage
- Log event BEFORE apply_hp_change for audit trail
- Use PERFORM for RPC calls in triggers (not SELECT)
- Store quest metadata for debugging

Follow 02-RESEARCH.md patterns for trigger structure.
  </action>
  <verify>
```bash
# Apply migration
cd /root/husatech/projekt-l
npx supabase db reset --local

# Test quest failure trigger
npx supabase db query "
DO \$\$
DECLARE
  test_user_id UUID := gen_random_uuid();
  test_quest_id UUID := gen_random_uuid();
BEGIN
  -- Setup
  INSERT INTO user_health (user_id, current_hp) VALUES (test_user_id, 50);
  INSERT INTO quests (id, user_id, title, status) VALUES (test_quest_id, test_user_id, 'Test Quest', 'active');

  -- Fail quest
  UPDATE quests SET status = 'failed' WHERE id = test_quest_id;

  -- Verify damage
  ASSERT (SELECT current_hp FROM user_health WHERE user_id = test_user_id) = 40, 'HP should be reduced by 10';
  ASSERT (SELECT COUNT(*) FROM health_events WHERE user_id = test_user_id AND event_type = 'quest_failed') = 1, 'Damage event logged';
END \$\$;
"
```
  </verify>
  <done>
- Quest failure trigger created
- Trigger only fires on status change to 'failed'
- HP reduced by 10 on quest failure
- health_events logs quest_failed event
  </done>
</task>

<task type="auto">
  <name>Task 2: Add HP Damage to Streak Break Logic</name>
  <files>src/app/api/habits/relapse/route.ts</files>
  <action>
Extend existing habits/relapse/route.ts to apply HP damage when streak is broken.

**Add after existing streak reset logic (around line 80-100):**
```typescript
// Apply HP damage for streak break
if (previousStreak > 0) {
  const damage = 5;

  // Log damage event
  const { error: eventError } = await adminClient.from('health_events').insert({
    user_id: userId,
    event_type: 'streak_break',
    hp_change: -damage,
    source_table: 'habits',
    source_id: habitId,
    metadata: {
      previous_streak: previousStreak,
      habit_name: habit.name,
      faction_id: habit.faction_id
    }
  });

  if (eventError) {
    console.error('Failed to log streak break HP damage:', eventError);
  }

  // Apply damage atomically
  const { error: hpError } = await adminClient.rpc('apply_hp_change', {
    p_user_id: userId,
    p_hp_change: -damage
  });

  if (hpError) {
    console.error('Failed to apply HP damage on streak break:', hpError);
  }
}
```

**Location:** Add this block right after the existing streak reset logic, before the notification code.

**Important:** Only apply damage if previousStreak > 0 (actual streak was broken, not just a miss on day 1).

Follow Phase 1 patterns: adminClient for server-side operations, error logging with console.error.
  </action>
  <verify>
```bash
# Test via API route
cd /root/husatech/projekt-l
npm run dev &
sleep 5

# Simulate streak break (requires authenticated user)
curl -X POST http://localhost:3000/api/habits/relapse \
  -H "Content-Type: application/json" \
  -d '{"habitId": "test-habit-id"}'

# Check logs for HP damage
tail -100 /root/husatech/projekt-l/.next/server.log | grep -i "streak break"
```
  </verify>
  <done>
- Streak break applies -5 HP via apply_hp_change
- health_events logs streak_break event with metadata
- Only triggers if previousStreak > 0
- Errors logged but don't block streak reset
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Inactivity Cron Scheduler</name>
  <files>
    src/instrumentation.ts
    src/app/api/health/inactivity-check/route.ts
  </files>
  <action>
**1. Create inactivity check API route:**

File: src/app/api/health/inactivity-check/route.ts
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase-admin';

export async function POST(request: NextRequest) {
  const adminClient = createAdminClient();

  try {
    // Get users with no activity in 3+ days
    const threeDaysAgo = new Date();
    threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

    // Query user_faction_stats for last_activity
    const { data: inactiveUsers, error: queryError } = await adminClient
      .from('user_faction_stats')
      .select('user_id, last_activity')
      .lt('last_activity', threeDaysAgo.toISOString())
      .not('last_activity', 'is', null);

    if (queryError) {
      console.error('Error querying inactive users:', queryError);
      return NextResponse.json({ error: 'Query failed' }, { status: 500 });
    }

    // Get unique users (user_faction_stats has 7 rows per user)
    const uniqueUsers = Array.from(
      new Map(inactiveUsers.map(u => [u.user_id, u])).values()
    );

    let damageApplied = 0;

    for (const user of uniqueUsers) {
      const daysSinceActivity = Math.floor(
        (Date.now() - new Date(user.last_activity).getTime()) / (1000 * 60 * 60 * 24)
      );

      // -5 HP per day inactive, max 25 HP damage
      const damage = Math.min(daysSinceActivity * 5, 25);

      // Log damage event
      await adminClient.from('health_events').insert({
        user_id: user.user_id,
        event_type: 'inactivity',
        hp_change: -damage,
        metadata: { days_inactive: daysSinceActivity }
      });

      // Apply damage
      const { error: hpError } = await adminClient.rpc('apply_hp_change', {
        p_user_id: user.user_id,
        p_hp_change: -damage
      });

      if (!hpError) {
        damageApplied++;
      }
    }

    return NextResponse.json({
      success: true,
      users_checked: uniqueUsers.length,
      damage_applied: damageApplied
    });
  } catch (error) {
    console.error('Inactivity check failed:', error);
    return NextResponse.json({ error: 'Internal error' }, { status: 500 });
  }
}
```

**2. Add cron scheduler to instrumentation.ts:**

Add after existing schedulers (proactiveScheduler, questExpiryScheduler):
```typescript
async function healthInactivityScheduler() {
  console.log('[CRON] Running health inactivity check...');

  const response = await fetch(`${BASE_URL}/api/health/inactivity-check`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' }
  });

  if (response.ok) {
    const result = await response.json();
    console.log('[CRON] Inactivity check complete:', result);
  } else {
    console.error('[CRON] Inactivity check failed:', response.status);
  }
}

// Schedule daily at 3 AM
schedule.scheduleJob('0 3 * * *', healthInactivityScheduler);
```

**Location in instrumentation.ts:** After existing scheduler declarations, before the conditional block that only runs in production.
  </action>
  <verify>
```bash
# Test inactivity check manually
cd /root/husatech/projekt-l
npm run dev &
sleep 5

curl -X POST http://localhost:3000/api/health/inactivity-check

# Check logs
tail -50 /root/husatech/projekt-l/.next/server.log | grep -i "inactivity"
```
  </verify>
  <done>
- /api/health/inactivity-check endpoint exists
- Endpoint identifies users with 3+ days inactivity
- -5 HP per day applied (max 25 HP)
- healthInactivityScheduler runs daily at 3 AM
- Logs inactivity damage events to health_events
  </done>
</task>

</tasks>

<verification>
**Trigger verification:**
```sql
-- Verify quest failure trigger exists
SELECT trigger_name, event_manipulation, event_object_table
FROM information_schema.triggers
WHERE trigger_name = 'quest_failure_hp_trigger';

-- Test quest failure flow
DO $$
DECLARE
  test_user_id UUID := gen_random_uuid();
  test_quest_id UUID := gen_random_uuid();
BEGIN
  INSERT INTO user_health (user_id, current_hp) VALUES (test_user_id, 100);
  INSERT INTO quests (id, user_id, title, status) VALUES (test_quest_id, test_user_id, 'Test', 'active');

  UPDATE quests SET status = 'failed' WHERE id = test_quest_id;

  ASSERT (SELECT current_hp FROM user_health WHERE user_id = test_user_id) = 90, 'Quest failure damage failed';
END $$;
```

**Inactivity check:**
```bash
# Simulate inactive user and test
curl -X POST http://localhost:3000/api/health/inactivity-check \
  -H "Content-Type: application/json"

# Verify response
# Expected: {"success": true, "users_checked": N, "damage_applied": M}
```
</verification>

<success_criteria>
**Must be true after completion:**
- [ ] Quest failure automatically applies -10 HP via trigger
- [ ] Streak break applies -5 HP via application logic
- [ ] Inactivity cron runs daily at 3 AM
- [ ] 3+ days inactivity applies -5 HP per day (max 25)
- [ ] All damage events logged to health_events
- [ ] No duplicate damage on repeated status changes
</success_criteria>

<output>
After completion, create `.planning/phases/02-konsequenzen-hp-death/02-03-SUMMARY.md`
</output>
