---
phase: 01-security-foundation
plan: 06
type: execute
wave: 4
depends_on: ["01-03", "01-04", "01-05"]
files_modified:
  - src/app/(protected)/soziales/page.tsx
  - src/app/(protected)/karriere/page.tsx
  - tests/e2e/security-validation.spec.ts
autonomous: false

must_haves:
  truths:
    - "User accessing /soziales page sees only their own birthday data and social interactions"
    - "User accessing /karriere page sees only their own career data"
    - "XSS payload injected via Quest creation does not execute when rendered"
    - "Full user workflow validates sanitization works end-to-end"
  artifacts:
    - path: "src/app/(protected)/soziales/page.tsx"
      provides: "Soziales page using authenticated user"
      contains: "supabase.auth.getUser()"
    - path: "src/app/(protected)/karriere/page.tsx"
      provides: "Karriere page using authenticated user"
      contains: "supabase.auth.getUser()"
    - path: "tests/e2e/security-validation.spec.ts"
      provides: "E2E security tests for XSS and user isolation"
      contains: "test.*XSS"
  key_links:
    - from: "src/app/(protected)/soziales/page.tsx"
      to: "supabase.auth.getUser()"
      via: "auth check"
      pattern: "getUser\\(\\)"
    - from: "src/app/(protected)/karriere/page.tsx"
      to: "supabase.auth.getUser()"
      via: "auth check"
      pattern: "getUser\\(\\)"
    - from: "tests/e2e/security-validation.spec.ts"
      to: "API routes"
      via: "fetch or browser interaction"
      pattern: "fetch.*api|page\\.goto"
---

<objective>
Verify SEC-01/SEC-02 fixes by ensuring soziales and karriere pages use authenticated user, and add E2E integration tests for XSS prevention.

Purpose: Complete Phase 1 verification by addressing the remaining security concerns: user data isolation on soziales/karriere pages, and full-workflow XSS validation through E2E tests.

Output: Fixed soziales/karriere pages (if still using hardcoded IDs), and comprehensive E2E test suite that validates XSS is prevented end-to-end.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation/01-03-SUMMARY.md
@.planning/phases/01-security-foundation/01-05-SUMMARY.md
@src/app/(protected)/soziales/page.tsx
@src/app/(protected)/karriere/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify and fix soziales page user isolation</name>
  <files>src/app/(protected)/soziales/page.tsx</files>
  <action>
    Check if soziales/page.tsx uses hardcoded user IDs. If found, fix them:

    **Check for patterns:**
    - `const userId = "..."` (hardcoded string)
    - `user_id: "..."`
    - Fallback UUIDs like `|| "00000000-..."`

    **If hardcoded IDs found, replace with:**
    ```typescript
    // For Server Component:
    import { createClient } from '@/lib/supabase/server';

    export default async function SozialesPage() {
      const supabase = await createClient();
      const { data: { user }, error } = await supabase.auth.getUser();

      if (error || !user) {
        redirect('/login');
      }

      // Use user.id for all queries
      const { data: socialData } = await supabase
        .from('contacts')
        .select('*')
        .eq('user_id', user.id);

      const { data: birthdays } = await supabase
        .from('contacts')
        .select('name, birthday')
        .eq('user_id', user.id)
        .not('birthday', 'is', null);

      // ... render with user-specific data
    }
    ```

    **If already fixed:** Verify the page correctly uses `supabase.auth.getUser()` and doesn't have any fallbacks.

    Key verification: The page MUST NOT show data from other users. Query must filter by authenticated user's ID.
  </action>
  <verify>Grep for hardcoded UUID patterns returns no matches; page loads only authenticated user's data</verify>
  <done>Soziales page uses authenticated user ID for all data queries</done>
</task>

<task type="auto">
  <name>Task 2: Verify and fix karriere page user isolation</name>
  <files>src/app/(protected)/karriere/page.tsx</files>
  <action>
    Check if karriere/page.tsx uses hardcoded user IDs. If found, fix them:

    **Check for patterns:**
    - `const userId = "..."` (hardcoded string)
    - `user_id: "..."`
    - Fallback UUIDs

    **If hardcoded IDs found, replace with:**
    ```typescript
    // For Server Component:
    import { createClient } from '@/lib/supabase/server';

    export default async function KarrierePage() {
      const supabase = await createClient();
      const { data: { user }, error } = await supabase.auth.getUser();

      if (error || !user) {
        redirect('/login');
      }

      // Use user.id for all career-related queries
      const { data: careerGoals } = await supabase
        .from('career_goals')
        .select('*')
        .eq('user_id', user.id);

      const { data: jobHistory } = await supabase
        .from('job_history')
        .select('*')
        .eq('user_id', user.id);

      // ... render with user-specific data
    }
    ```

    **If already fixed:** Verify the page correctly uses `supabase.auth.getUser()`.

    Key verification: Career data shown must belong to authenticated user only.
  </action>
  <verify>Grep for hardcoded UUID patterns returns no matches; page loads only authenticated user's data</verify>
  <done>Karriere page uses authenticated user ID for all data queries</done>
</task>

<task type="auto">
  <name>Task 3: Create E2E XSS integration test</name>
  <files>tests/e2e/security-validation.spec.ts</files>
  <action>
    Create Playwright E2E test that validates XSS prevention works end-to-end:

    ```typescript
    import { test, expect } from '@playwright/test';

    test.describe('Security Validation', () => {
      test.beforeEach(async ({ page }) => {
        // Login as test user (use auth helper from Phase 3 if available)
        // For now, use cookie-based or API-based auth
      });

      test('XSS payload in Quest title is rejected', async ({ page }) => {
        // Navigate to quest creation
        await page.goto('/quests/new');

        // Enter XSS payload
        await page.fill('input[name="title"]', '<script>alert("XSS")</script>');
        await page.fill('textarea[name="description"]', 'Normal description');
        await page.click('button[type="submit"]');

        // Verify error message (400 validation error)
        await expect(page.locator('.error-message')).toContainText('Cannot contain');
        // OR: Verify script is sanitized
        // await expect(page.locator('.quest-title')).not.toContainText('<script>');
      });

      test('XSS payload in Quest description is sanitized', async ({ page }) => {
        // Create quest via API with XSS in description
        const response = await page.request.post('/api/quests/create', {
          data: {
            title: 'Valid Title',
            description: '<script>alert("XSS")</script><b>Bold text</b>',
            xp_reward: 100,
            skill_id: 'valid-skill-uuid'
          }
        });

        // Should succeed but sanitize
        expect(response.status()).toBe(201);

        // Navigate to quest page
        const quest = await response.json();
        await page.goto(`/quests/${quest.id}`);

        // Verify script tag is stripped but bold is kept
        const description = page.locator('.quest-description');
        await expect(description).not.toContainText('<script>');
        await expect(description.locator('b')).toContainText('Bold text');
      });

      test('Sanitized content renders without executing JavaScript', async ({ page }) => {
        // Setup: Create quest with various XSS payloads via direct DB insert
        // (This tests that even if something slips through, rendering is safe)

        const xssPayloads = [
          '<img src=x onerror=alert("XSS")>',
          '<svg onload=alert("XSS")>',
          'javascript:alert("XSS")',
          '<a href="javascript:alert(\'XSS\')">Click</a>'
        ];

        // Create console listener to catch any alert() calls
        const alerts: string[] = [];
        page.on('dialog', async dialog => {
          alerts.push(dialog.message());
          await dialog.dismiss();
        });

        // Navigate to page with potentially dangerous content
        await page.goto('/quests');

        // Wait for page to fully load
        await page.waitForLoadState('networkidle');

        // Verify no alerts were triggered
        expect(alerts).toHaveLength(0);
      });

      test('User cannot see other user data on soziales page', async ({ page }) => {
        // This test requires two test users
        // Login as User A
        await page.goto('/soziales');

        // Get User A's contacts
        const userAContacts = await page.locator('.contact-card').count();

        // Verify the page shows User A's data (not empty if User A has contacts)
        // and doesn't show User B's data (verified by count or specific names)

        // Check that no hardcoded UUID appears in network requests
        const requests: string[] = [];
        page.on('request', req => {
          if (req.url().includes('00000000-0000-0000-0000-000000000001')) {
            requests.push(req.url());
          }
        });

        await page.reload();
        expect(requests).toHaveLength(0);
      });

      test('User cannot see other user data on karriere page', async ({ page }) => {
        await page.goto('/karriere');

        // Check that no hardcoded UUID appears in network requests
        const requests: string[] = [];
        page.on('request', req => {
          if (req.url().includes('00000000-0000-0000-0000-000000000001')) {
            requests.push(req.url());
          }
        });

        await page.reload();
        expect(requests).toHaveLength(0);

        // Verify page loads user's career data
        await expect(page.locator('h1')).toContainText('Karriere');
      });
    });
    ```

    Note: If Playwright is not set up yet (Phase 3), create the test file structure anyway - it will be runnable after Phase 3 E2E infrastructure.
  </action>
  <verify>Test file exists and TypeScript compiles; tests will run after Phase 3</verify>
  <done>E2E security tests created for XSS and user isolation</done>
</task>

</tasks>

<verification>
1. `grep -r "00000000-0000-0000-0000-000000000001" src/app/(protected)/` returns no matches
2. soziales/page.tsx contains `supabase.auth.getUser()` call
3. karriere/page.tsx contains `supabase.auth.getUser()` call
4. tests/e2e/security-validation.spec.ts exists with XSS tests
5. `npx tsc --noEmit tests/e2e/security-validation.spec.ts` compiles (if Playwright types exist)
</verification>

<success_criteria>
- Soziales page loads only authenticated user's contacts and birthdays
- Karriere page loads only authenticated user's career data
- No hardcoded UUIDs remain in soziales or karriere pages
- E2E test validates XSS is rejected/sanitized in Quest creation
- E2E test validates no JavaScript executes from sanitized content
- E2E test validates user isolation on soziales/karriere pages
</success_criteria>

<checkpoint type="human-verify" gate="blocking">
  <what-built>
    - Fixed soziales and karriere pages to use authenticated user
    - Created E2E security validation tests
  </what-built>
  <how-to-verify>
    1. Visit /soziales as logged-in user - verify you see YOUR contacts/birthdays
    2. Visit /karriere as logged-in user - verify you see YOUR career data
    3. Try creating a Quest with title `<script>alert(1)</script>` - should fail validation
    4. Check browser console for any XSS-related errors
  </how-to-verify>
  <resume-signal>Type "verified" if pages show correct user data and XSS is blocked</resume-signal>
</checkpoint>

<output>
After completion, create `.planning/phases/01-security-foundation/01-06-SUMMARY.md`
</output>
