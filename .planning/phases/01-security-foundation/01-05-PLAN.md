---
phase: 01-security-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-01", "01-03"]
files_modified:
  - src/app/api/quests/create/route.ts
  - src/app/api/habits/create/route.ts
  - src/app/api/user/profile/route.ts
autonomous: true

must_haves:
  truths:
    - "Quest creation API validates input with Zod schema"
    - "Habit creation API validates input with Zod schema"
    - "Profile update API validates input with Zod schema"
    - "All APIs sanitize text fields before database insert"
    - "XSS payloads in title/description are rejected or sanitized"
  artifacts:
    - path: "src/app/api/quests/create/route.ts"
      provides: "Quest creation with validation and sanitization"
      contains: "questCreateSchema.safeParse"
    - path: "src/app/api/habits/create/route.ts"
      provides: "Habit creation with validation and sanitization"
      contains: "habitCreateSchema.safeParse"
    - path: "src/app/api/user/profile/route.ts"
      provides: "Profile update with validation and sanitization"
      contains: "profileUpdateSchema.safeParse"
  key_links:
    - from: "src/app/api/quests/create/route.ts"
      to: "@/lib/validation"
      via: "import validation schemas"
      pattern: "import.*from '@/lib/validation'"
    - from: "src/app/api/habits/create/route.ts"
      to: "@/lib/validation"
      via: "import validation schemas"
      pattern: "import.*from '@/lib/validation'"
    - from: "src/app/api/user/profile/route.ts"
      to: "@/lib/validation"
      via: "import validation schemas"
      pattern: "import.*from '@/lib/validation'"
---

<objective>
Integrate Zod validation and XSS sanitization into Quest, Habit, and Profile API routes.

Purpose: Complete SEC-05, SEC-06, SEC-07 by adding server-side input validation that rejects malicious input and sanitizes text fields before database storage.

Output: All user-input API routes validate with Zod schemas, sanitize HTML content, and return 400 Bad Request for invalid input.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation/01-RESEARCH.md
@src/lib/validation/index.ts (after Plan 01 completes)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validation to Quest create/update API</name>
  <files>src/app/api/quests/create/route.ts</files>
  <action>
    Update the quest creation API route to:

    1. Import validation schemas and sanitization:
    ```typescript
    import { questCreateSchema, sanitizeHtml, sanitizeText } from '@/lib/validation';
    ```

    2. Validate request body:
    ```typescript
    export async function POST(request: NextRequest) {
      // Auth check (should already exist)
      const supabase = await createClient();
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      // Parse and validate input
      const body = await request.json();
      const validation = questCreateSchema.safeParse(body);

      if (!validation.success) {
        return NextResponse.json(
          {
            error: 'Validation failed',
            details: validation.error.flatten().fieldErrors
          },
          { status: 400 }
        );
      }

      // Sanitize text fields
      const sanitized = {
        ...validation.data,
        title: sanitizeText(validation.data.title),
        description: validation.data.description
          ? sanitizeHtml(validation.data.description)
          : undefined,
      };

      // Insert to database
      const { data: quest, error: dbError } = await supabase
        .from('quests')
        .insert({
          ...sanitized,
          user_id: user.id,
          status: 'active',
        })
        .select()
        .single();

      // ... rest of response
    }
    ```

    If there's a quest update route, apply the same pattern with questUpdateSchema.

    Key points:
    - Validate BEFORE any database operation
    - Return 400 with field-level errors
    - Sanitize AFTER validation passes
    - Use sanitizeText for titles, sanitizeHtml for descriptions
  </action>
  <verify>Test with curl: `curl -X POST /api/quests/create -d '{"title":"<script>alert(1)</script>"}' ` returns 400</verify>
  <done>Quest API validates input and rejects/sanitizes XSS payloads</done>
</task>

<task type="auto">
  <name>Task 2: Add validation to Habit create/update API</name>
  <files>src/app/api/habits/create/route.ts</files>
  <action>
    Update the habit creation API route with same pattern:

    1. Import validation:
    ```typescript
    import { habitCreateSchema, sanitizeText } from '@/lib/validation';
    ```

    2. Validate and sanitize:
    ```typescript
    const body = await request.json();
    const validation = habitCreateSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        {
          error: 'Validation failed',
          details: validation.error.flatten().fieldErrors
        },
        { status: 400 }
      );
    }

    const sanitized = {
      ...validation.data,
      name: sanitizeText(validation.data.name),
      description: validation.data.description
        ? sanitizeText(validation.data.description)
        : undefined,
    };

    // Insert with sanitized data
    ```

    Ensure faction weights validation:
    - Factions array items have faction_id (uuid) and weight (0-100)
    - Total weight should sum to 100 (if provided)

    Apply same pattern to habit update route if it exists.
  </action>
  <verify>Test with curl: `curl -X POST /api/habits/create -d '{"name":"<script>"}' ` returns 400</verify>
  <done>Habit API validates input and rejects/sanitizes XSS payloads</done>
</task>

<task type="auto">
  <name>Task 3: Add validation to Profile update API</name>
  <files>src/app/api/user/profile/route.ts</files>
  <action>
    Find or create the profile update API route. Apply validation pattern:

    1. Import validation:
    ```typescript
    import { profileUpdateSchema, sanitizeText, sanitizeHtml } from '@/lib/validation';
    ```

    2. For PUT/PATCH endpoint:
    ```typescript
    export async function PATCH(request: NextRequest) {
      // Auth check
      const supabase = await createClient();
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      const body = await request.json();
      const validation = profileUpdateSchema.safeParse(body);

      if (!validation.success) {
        return NextResponse.json(
          {
            error: 'Validation failed',
            details: validation.error.flatten().fieldErrors
          },
          { status: 400 }
        );
      }

      const sanitized = {
        ...validation.data,
        display_name: validation.data.display_name
          ? sanitizeText(validation.data.display_name)
          : undefined,
        bio: validation.data.bio
          ? sanitizeHtml(validation.data.bio)
          : undefined,
      };

      // Update user_profiles table
      const { data: profile, error: dbError } = await supabase
        .from('user_profiles')
        .update(sanitized)
        .eq('user_id', user.id)
        .select()
        .single();

      // ... response
    }
    ```

    If profile route doesn't exist at this path, check for:
    - src/app/api/profile/route.ts
    - src/app/api/users/[id]/route.ts
    - src/app/api/settings/profile/route.ts

    Create the route if it doesn't exist, or update the existing one.
  </action>
  <verify>Test with curl: `curl -X PATCH /api/user/profile -d '{"display_name":"<img onerror=alert(1)>"}' ` returns 400 or sanitizes</verify>
  <done>Profile API validates input and rejects/sanitizes XSS payloads</done>
</task>

</tasks>

<verification>
1. Quest creation rejects title with `<script>` tag (400 response)
2. Quest creation sanitizes description HTML (strips script tags)
3. Habit creation rejects name with `<` or `>` characters (400 response)
4. Profile update rejects display_name with HTML (400 response)
5. Profile update sanitizes bio HTML (allows b, i, a tags, strips script)
6. All APIs return proper error structure: `{ error: string, details?: object }`
7. `npx tsc --noEmit` passes with no errors
</verification>

<success_criteria>
- All three API routes import from @/lib/validation
- All routes use .safeParse() for validation
- All routes return 400 with details for invalid input
- All routes sanitize text fields before database insert
- XSS payloads like `<script>alert(1)</script>` are rejected or sanitized
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-05-SUMMARY.md`
</output>
