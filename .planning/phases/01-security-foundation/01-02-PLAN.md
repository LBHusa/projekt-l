---
phase: 01-security-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260122_001_rls_performance_indexes.sql
autonomous: true

must_haves:
  truths:
    - "All user_id columns in RLS-protected tables have BTREE indexes"
    - "RLS policy predicates use (SELECT auth.uid()) pattern for caching"
    - "Index creation uses CONCURRENTLY to avoid table locks"
  artifacts:
    - path: "supabase/migrations/20260122_001_rls_performance_indexes.sql"
      provides: "Performance indexes for RLS policies"
      contains: "CREATE INDEX CONCURRENTLY"
      min_lines: 50
  key_links:
    - from: "supabase/migrations/20260122_001_rls_performance_indexes.sql"
      to: "existing RLS policies in 20260116_rls_policies.sql"
      via: "indexes on user_id columns"
      pattern: "idx_.*_user_id"
---

<objective>
Create performance indexes for all RLS-protected tables to prevent query degradation.

Purpose: Research shows RLS policies without indexes can cause 100x+ performance degradation. This migration adds BTREE indexes on user_id columns for all 49 tables with RLS policies, and optimizes policy predicates to cache auth.uid() calls.

Output: SQL migration file ready to be applied to Supabase, ensuring RLS queries use Index Scans instead of Sequential Scans.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation/01-RESEARCH.md
@supabase/migrations/20260116_rls_policies.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS performance indexes migration</name>
  <files>supabase/migrations/20260122_001_rls_performance_indexes.sql</files>
  <action>
    Create migration file with BTREE indexes on user_id columns for ALL tables in the RLS policies migration (20260116_rls_policies.sql).

    Tables requiring indexes (from existing RLS migration):
    - accounts, activity_log, ai_faction_suggestions_feedback, body_metrics
    - books, budgets, career_goals, career_sources, contact_interactions
    - contacts, courses, experiences, finance_achievements, finance_streaks
    - google_calendar_integrations, habit_logs, habit_reminders, habits
    - health_import_logs, hobby_projects, hobby_time_logs, investments
    - job_history, journal_entries, mental_stats_logs, mood_logs
    - net_worth_history, notification_log, notification_settings, notion_integrations
    - quest_actions, quests, recurring_flows, reminder_delivery_log
    - salary_entries, savings_goals, sleep_logs, social_events
    - training_plans, transaction_categories, transactions, user_achievements
    - user_api_keys, user_faction_stats, user_profiles, user_quest_preferences
    - user_skills, workout_sessions, workouts

    Pattern for each table:
    ```sql
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_{table}_user_id
      ON {table} USING btree (user_id);
    ```

    Also add composite indexes for commonly filtered tables:
    - `idx_quests_user_status ON quests(user_id, status)` - for filtering active/completed quests
    - `idx_habits_user_active ON habits(user_id, is_active)` - for filtering active habits
    - `idx_habit_logs_user_date ON habit_logs(user_id, logged_at)` - for date range queries

    Include header comment explaining:
    - Why indexes are needed (RLS performance)
    - CONCURRENTLY keyword prevents table locks
    - IF NOT EXISTS makes migration idempotent
  </action>
  <verify>SQL syntax is valid: `npx supabase db lint` or manual review</verify>
  <done>Migration file exists with indexes for all 49 RLS-protected tables plus composite indexes</done>
</task>

<task type="auto">
  <name>Task 2: Document performance optimization patterns</name>
  <files>supabase/migrations/20260122_001_rls_performance_indexes.sql</files>
  <action>
    Add SQL comment block at end of migration with verification queries:

    ```sql
    -- ============================================
    -- VERIFICATION QUERIES
    -- Run these after migration to verify indexes
    -- ============================================

    -- Check all indexes exist:
    -- SELECT indexname FROM pg_indexes
    -- WHERE tablename IN ('habits', 'quests', 'user_skills')
    -- AND indexname LIKE 'idx_%_user_id';

    -- Verify Index Scan is used (not Seq Scan):
    -- EXPLAIN ANALYZE
    -- SELECT * FROM habits WHERE user_id = 'your-user-uuid';

    -- Check RLS performance:
    -- SET ROLE authenticated;
    -- SET request.jwt.claim.sub = 'your-user-uuid';
    -- EXPLAIN ANALYZE SELECT * FROM habits;
    ```

    Add note about RLS policy optimization (for future reference):
    ```sql
    -- NOTE: For optimal performance, RLS policies should use:
    --   USING ((SELECT auth.uid()) = user_id)
    -- Instead of:
    --   USING (auth.uid() = user_id)
    -- The SELECT wrapper caches the auth.uid() call.
    -- This is already handled by Supabase's auth.user_id() helper function.
    ```
  </action>
  <verify>Migration file contains verification queries in comments</verify>
  <done>Migration includes performance verification queries and optimization notes</done>
</task>

</tasks>

<verification>
1. Migration file exists at correct path
2. All 49 tables from RLS migration have corresponding indexes
3. All indexes use `CREATE INDEX CONCURRENTLY IF NOT EXISTS`
4. Composite indexes exist for quests, habits, habit_logs
5. SQL syntax is valid (no syntax errors)
6. Verification queries are included in comments
</verification>

<success_criteria>
- Migration file creates 49+ indexes (one per RLS table + composites)
- Uses CONCURRENTLY to avoid table locks
- Uses IF NOT EXISTS for idempotency
- Includes verification queries in comments
- Ready to apply via `supabase db push` or SQL editor
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-02-SUMMARY.md`
</output>
